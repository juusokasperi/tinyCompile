==================================================
FILE: ./incs/ast.h
==================================================
#ifndef AST_H 
# define AST_H 

# include "string_view.h"

typedef enum {
	AST_NUMBER,
	AST_IDENTIFIER,

	AST_ADD,
	AST_SUB,
	AST_MUL,
	AST_DIV,

	AST_NEGATE,		// -x
	AST_NOT,		// !x

	AST_EQUAL,
	AST_NOT_EQUAL,
	AST_LESS,
	AST_LESS_EQUAL,
	AST_GREATER,
	AST_GREATER_EQUAL,

	AST_VAR_DECL,
	AST_ASSIGNMENT,
	AST_IF,
	AST_WHILE,
	AST_BLOCK,
	AST_RETURN,

	AST_FUNCTION,
	AST_TRANSLATION_UNIT,
	AST_CALL,
} ASTNodeType;

typedef enum {
	TYPE_VOID,
	TYPE_INT64,
	TYPE_CHAR,
	// TYPE_INT32,
	// TYPE_UINT32,
	// TYPE_POINTER
	// etc..
} DataType;

typedef struct {
	StringView name;
	DataType type;
} Parameter;

typedef struct ASTNode ASTNode;

struct ASTNode {
	ASTNodeType type;
	int line, column;

	union
	{
		struct
		{
			StringView value;
		} number;

		struct
		{
			StringView name;
		} identifier;

		struct
		{ 
			ASTNode *left;
			ASTNode *right;
		} binary;

		struct {
			ASTNode *operand;
		} unary;

		struct
		{
			ASTNode	*condition;
			ASTNode *then_branch;
			ASTNode *else_branch; // NULL if no else 
		} if_stmt;

		struct {
			ASTNode *condition;
			ASTNode *body;
		} while_stmt;

		struct {
			ASTNode *expression;
		} return_stmt;

		struct {
			StringView 	var_name;
			ASTNode		*initializer;
		} var_decl;

		struct {
			StringView	var_name;
			ASTNode 	*value;
		} assignment;

		struct {
			ASTNode 	**statements;
			size_t 		count;
		} block;

		struct {
			StringView	name;
			Parameter	*params;
			size_t 		param_count;
			ASTNode		*body;
			bool		is_prototype;
		} function;

		struct {
			ASTNode **declarations;
			size_t	count;
		} translation_unit;

		struct {
			StringView function_name;
			ASTNode **args;
			size_t arg_count;
		} call;
	};
};

void	print_ast(ASTNode *node, int indent);

#endif


==================================================
FILE: ./incs/bounds.h
==================================================
#ifndef BOUNDS_H
# define BOUNDS_H

# include <stddef.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>

static inline bool bounds_check(size_t index, size_t capacity, const char *array_name)
{
	if (index >= capacity)
	{
		fprintf(stderr, "Array bounds violation: %s[%zu] (capacity: %zu)\n",
				array_name, index, capacity);
		return (false);
	}
	return (true);
}

#define SAFE_INDEX(array, index, capacity) \
    (bounds_check((index), (capacity), #array) ? &(array)[index] : NULL)

static inline bool safe_increment(size_t *value, size_t limit, const char *name)
{
    if (limit == 0 || *value >= limit - 1) {
        fprintf(stderr, "Counter overflow: %s (limit: %zu)\n", name, limit);
        return false;
    }
    (*value)++;
    return true;
}

static inline bool safe_add(size_t *dest, size_t value, size_t limit, const char *name)
{
    if (value > limit || *dest > limit - value) {
        fprintf(stderr, "Addition overflow: %s (limit: %zu)\n", name, limit);
        return false;
    }
    *dest += value;
    return true;
}

#ifdef DEBUG_BOUNDS
#define BOUNDS_INFO(array, index, capacity) \
    fprintf(stderr, "[BOUNDS] %s[%zu/%zu] at %s:%d\n", \
            #array, (size_t)(index), (size_t)(capacity), __FILE__, __LINE__)
#else
#define BOUNDS_INFO(array, index, capacity) ((void)0)
#endif

#endif // BOUNDS_H


==================================================
FILE: ./incs/cleanup.h
==================================================
#ifndef CLEANUP_H
# define  CLEANUP_H

# include <stdbool.h>
# include <stddef.h>
# include <sys/mman.h>
# include <unistd.h>
# include "memarena.h"

typedef struct {
	int		fd;
	void	*addr;
	size_t	size;
	bool	needs_close;
	bool	needs_munmap;
} FileResource;

typedef struct {
	FileResource	*files;
	size_t			count;
	size_t			capacity;
	Arena			*arena;
} ResourceTracker;

void	resource_tracker_init(ResourceTracker *tracker, size_t capacity, Arena *a);
void	resource_track_fd(ResourceTracker *tracker, int fd);
void	resource_track_mmap(ResourceTracker *tracker, void *addr, size_t size);
void	resource_track_file(ResourceTracker *tracker, int fd, void *addr, size_t size);
void	resource_cleanup_all(ResourceTracker *tracker);
void	resource_untrack_fd(ResourceTracker *tracker, int fd);

#endif


==================================================
FILE: ./incs/compile.h
==================================================
#ifndef COMPILE_H
# define COMPILE_H

# include "ast.h"
# include "file_map.h"
# include "memarena.h"
# include "semantic.h"
# include "error_handler.h"
# include "cleanup.h"
# include <stdbool.h>
# include <stddef.h>

typedef struct CompilationUnit {
	FileMap	file;
	ASTNode	*ast;
	bool	parsed_ok;
} CompilationUnit;

typedef struct {
	CompilationUnit	*units;
	size_t 			count;
	size_t			capacity;
	Arena			*arena;
	ErrorContext	*errors;
	GlobalScope		global;
} CompilationContext;

bool	compile_ctx_init(CompilationContext *ctx, Arena *arena, 
					ErrorContext *errors, size_t file_count);
bool	compile_ctx_add_file(CompilationContext *ctx, const char *filepath,
					ResourceTracker *resources);
bool	compile_parse_all(CompilationContext *ctx);
bool	compile_analyze_all(CompilationContext *ctx);
void	compile_print_errors(CompilationContext *ctx);
ASTNode	*compile_get_entry_point(CompilationContext *ctx);

#endif


==================================================
FILE: ./incs/defines.h
==================================================
#ifndef DEFINES_H
# define DEFINES_H

# define MAX_SOURCE_FILES			64
# define IR_CHUNK_SIZE				64 
# define MAX_PARAMS_PER_FUNCTION	32
# define MAX_VARS_PER_SCOPE			256
# define MAX_FUNCTION_COUNT			256
# define MAX_CALL_SITES				1024
# define SYMBOL_TABLE_SIZE			4096
# define MAX_LABELS					512
# define MAX_BLOCK_STATEMENTS		512
# define MAX_EXPRESSION_DEPTH		128
# define MAX_VREGS_PER_FUNCTION		65536

#define CHECK_LIMIT(value, limit, name) \
    do { \
        if ((value) >= (limit)) { \
            fprintf(stderr, "Limit exceeded: %s (got %zu, max %zu)\n", \
                    name, (size_t)(value), (size_t)(limit)); \
            return false; \
        } \
    } while (0)

#define CHECK_LIMIT_NULL(value, limit, name) \
    do { \
        if ((value) >= (limit)) { \
            fprintf(stderr, "Limit exceeded: %s (got %zu, max %zu)\n", \
                    name, (size_t)(value), (size_t)(limit)); \
            return NULL; \
        } \
    } while (0)

// Static assertions to ensure sane defaults
_Static_assert((SYMBOL_TABLE_SIZE & (SYMBOL_TABLE_SIZE - 1)) == 0, 
               "SYMBOL_TABLE_SIZE must be power of 2");
_Static_assert(MAX_PARAMS_PER_FUNCTION <= 255,
               "MAX_PARAMS_PER_FUNCTION must fit in uint8_t");

#endif


==================================================
FILE: ./incs/error_handler.h
==================================================
#ifndef ERROR_HANDLER_H
# define ERROR_HANDLER_H

# include "memarena.h"
# include <stdbool.h>
# include <stdarg.h>
#include <stddef.h>

typedef enum {
	ERROR_LEXER,
	ERROR_PARSER,
	ERROR_SEMANTIC,
	ERROR_CODEGEN,
	ERROR_SYSTEM,
} ErrorCategory;

typedef enum {
	ERROR_LEVEL_WARNING,
	ERROR_LEVEL_ERROR,
	ERROR_LEVEL_FATAL,
} ErrorLevel;

typedef struct ErrorNode ErrorNode;

struct ErrorNode {
	ErrorCategory	category;
	ErrorLevel		level;
	const char		*message;
	const char		*filename;
	int				line;
	int				column;
	ErrorNode		*next;
};

typedef struct {
	ErrorNode	*head;
	ErrorNode	*tail;
	size_t		error_count;
	size_t		warning_count;
	Arena		*arena;
} ErrorContext;

void	error_context_init(ErrorContext *ctx, Arena *a);
void	error_add(ErrorContext *ctx, ErrorCategory category, ErrorLevel level,
			const char *filename, int line, int column, 
			const char *fmt, ...) __attribute__((format(printf, 7, 8)));

#define error_lexer(ctx, file, line, col, ...) \
	error_add(ctx, ERROR_LEXER, ERROR_LEVEL_ERROR, file, line, col, __VA_ARGS__)
#define error_parser(ctx, file, line, col, ...) \
	error_add(ctx, ERROR_PARSER, ERROR_LEVEL_ERROR, file, line, col, __VA_ARGS__)
#define error_semantic(ctx, file, line, col, ...) \
	error_add(ctx, ERROR_SEMANTIC, ERROR_LEVEL_ERROR, file, line, col, __VA_ARGS__)
#define error_fatal(ctx, file, line, col, ...) \
	error_add(ctx, ERROR_SYSTEM, ERROR_LEVEL_FATAL, file, line, col, __VA_ARGS__)
#define warning_add(ctx, file, line, col, ...) \
	error_add(ctx, ERROR_PARSER, ERROR_LEVEL_WARNING, file, line, col, __VA_ARGS__)

bool	error_has_errors(ErrorContext *ctx);
bool	error_has_fatal(ErrorContext *ctx);
void	error_print_all(ErrorContext *ctx);

#endif // ERROR_HANDLER_H


==================================================
FILE: ./incs/file_map.h
==================================================
#ifndef FILE_MAP_H
# define FILE_MAP_H

# include <stddef.h>

typedef struct {
	const char	*data;
	size_t 		length;
	const char	*name;
} FileMap;

FileMap map_input(int fd);

#endif // FILE_MAP_H


==================================================
FILE: ./incs/ir.h
==================================================
#ifndef IR_H
# define IR_H

# include "memarena.h"
# include "ast.h"
# include "string_view.h"
# include "defines.h"
# include <stdbool.h>
# include <stdlib.h>
# include <stddef.h>

typedef struct ScopeChange ScopeChange;

typedef struct {
	StringView	name;
	size_t		vreg;
	bool		occupied;
} Symbol;

struct ScopeChange {
	size_t		index;
	Symbol		previous;
	ScopeChange	*next;
};

typedef struct {
	Symbol		entries[SYMBOL_TABLE_SIZE];
	Arena		*arena;
	ScopeChange	*changes;
} SymbolTable;

typedef enum {
	FMT_NONE,
	FMT_BIN,	// dest = src_1 op src_2
	FMT_UNARY,	// dest = op src_1
	FMT_IMM,	// dest = imm
	FMT_CALL,	// dest = call name
	FMT_ARG,	// arg imm = src_1
	FMT_JUMP,	// jmp label
	FMT_BRANCH,	// op src_1, label
	FMT_LABEL	// label1:
}	IROpcodeFormat;

typedef enum {
	#define X_OP(opcode, name, fmt, encoder) opcode,
	#include "ir_ops.def"
	#undef X_OP
} 	IROpcode;

typedef struct {
	IROpcode	opcode;
	DataType	type;
	size_t		dest;	// Virtual register ID 
	size_t		src_1;
	size_t		src_2;
	int64_t		imm;	// Immediate value for IR_CONST
	StringView	func_name;
	size_t		label_id;
} IRInstruction;

typedef struct IRChunk IRChunk;

struct IRChunk {
	IRChunk			*next;
	IRInstruction	instructions[IR_CHUNK_SIZE];
	size_t			count;
};

typedef struct {
	IRChunk		*head;
	IRChunk		*tail;
	size_t		total_count;
	size_t		vreg_count;
	size_t		label_count;
	StringView	name;
} IRFunction;

void			symbol_table_restore(SymbolTable *st, ScopeChange *target_state);
Symbol*			symbol_table_lookup(SymbolTable *st, StringView name);
void			symbol_table_add(SymbolTable *st, StringView name, size_t vreg);

IRFunction		*ir_gen(Arena *a, ASTNode *root);
void			ir_print(IRFunction *func);

const char		*ir_opcode_name(IROpcode op);
IROpcodeFormat	ir_opcode_format(IROpcode op);

#define IR_NEXT_VREG(f) \
    ( \
        ((f)->vreg_count >= MAX_VREGS_PER_FUNCTION) ? \
        ( \
            fprintf(stderr, \
				"  > JIT INTERNAL ERROR\n" \
				"    function '%.*s' vreg exceeds limit %d\n", \
                    (int)(f)->name.len, (f)->name.start, MAX_VREGS_PER_FUNCTION), \
            exit(1), \
            0 \
        ) \
        : \
        ((f)->vreg_count++) \
    )

#endif


==================================================
FILE: ./incs/jit_internal.h
==================================================
#ifndef JIT_INTERNAL_H
# define JIT_INTERNAL_H

# include "jit.h"

/* --- Shared Globals defined in jit.c --- */
extern const X86Reg arg_registers[6];

/* --- Shared Helpers --- */
Location get_location(JITContext *ctx, size_t vreg);

/* --- Encoder Prototypes (Auto-Generated) --- */
#define X_OP(opcode, name, fmt, encoder) \
    size_t encoder(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx);
#include "ir_ops.def"
#undef X_OP

#endif


==================================================
FILE: ./incs/jit.h
==================================================
#ifndef JIT_H
# define JIT_H

# include <stdbool.h>
# include <stdint.h>
# include <stddef.h>
# include "defines.h"
# include "string_view.h"
# include "ir.h"
# include "memarena.h"
# include "error_handler.h"
# include "compile.h"

typedef enum {
    REG_RAX = 0,
    REG_RCX = 1,
    REG_RDX = 2,
    REG_RBX = 3,
    REG_RSP = 4,
    REG_RBP = 5,
    REG_RSI = 6,
    REG_RDI = 7,
	REG_R8 = 8,
	REG_R9 = 9,
} X86Reg;

typedef enum {
	REX_W = 0x48,	// 64-bit Operand Size
	REX_WB = 0x49,	// REX.W + REX_B (for R8-R15)
} X86Prefix;

typedef enum {
	CC_E = 0x4,		// Equal / Zero
	CC_NE = 0x5,	// Not Equal / Not Zero
	CC_L = 0xC,		// Less
	CC_GE = 0xD,	// Greater or Equal
	CC_LE = 0xE,	// Less or equal
	CC_G = 0xF,		// Greater
} X86Condition;

typedef enum {
	ALU_ADD = 0x01,
	ALU_OR = 0x09,
	ALU_AND = 0x21,
	ALU_SUB = 0x29,
	ALU_XOR = 0x31,
	ALU_CMP = 0x39,
	ALU_IMM = 0x81,		// 32-bit immediate
	ALU_IMM8 = 0x83,	// Add/Cmp/Sub r/m, imm8
	ALU_TEST = 0x85,

	MOV_RM_R = 0x89,	// Store: Move register to r/m
	MOV_R_RM = 0x8B,	// Load: Move r/m to register
	MOV_IMM_R = 0xB8,	// Imm: Mov imm64 to register
	
	OP_PUSH = 0x50,		// Push reg
	OP_POP = 0x58,
	OP_RET = 0xC3,
	OP_LEAVE = 0xC9,	// Leave (mov rsp, rbp; pop rbp)
	OP_CALL_IND = 0xFF,	// Call indirect (call rax)
	
	OP_JMP_REL32 = 0xE9,	// JMP rel32
	OP_PREFIX_0F = 0x0F,	// Prefix for 2-byte opcodes
	OP_MOVZX = 0xB6,		// MOVZX r64, r/m8 (w/ 0f prefix)

	OP_CQO = 0x99,		// Sign extend (RAX -> RDX)
	OP_IDIV = 0xF7,		// Integer division
	OP_IMUL_1 = 0x0F,
	OP_IMUL_2 = 0xAF,	// 2nd byte of IMUL (1st is 0x0F)
} X86Opcode;

typedef enum {
	MOD_MEM = 0x00,			// [reg]
	MOD_MEM_DISP8 = 0x40, 	// [reg + disp8]
	MOD_MEM_DISP32 = 0x80, 	// [reg + disp32]
	MOD_REG = 0xC0,			// reg (direct register access)
} X86ModMode;

typedef enum {
	EXT_ADD = 0,
	EXT_CALL = 2,
	EXT_NEG = 3,
	EXT_SUB = 5,
	EXT_IDIV = 7,
	EXT_CMP = 7,
} X86Extension;

typedef enum {
	LOC_REG,
	LOC_STACK,
	LOC_CONST
} LocationType;

typedef struct {
	LocationType type;
	union 
	{
		X86Reg	reg;
		int32_t	offset;
		int64_t	imm;
	};
} Location;

typedef struct {
	uint8_t *code;
	size_t size;
} JITResult;

typedef int64_t (*JITFunc)(void);

typedef struct Patch Patch;

struct Patch {
	size_t	label_id;
	uint8_t	*loc;
	Patch	*next;
};

typedef struct {
	StringView	name;
	uint8_t		*code_addr;
	size_t		code_size;
} CompiledFunction;

typedef struct {
	CompiledFunction	*functions;
	size_t				count;
	size_t				capacity;
} FunctionRegistry;

typedef struct {
	uint8_t		*patch_location;
	StringView	target_name;
} CallSite;

typedef struct {
	CallSite	*sites;
	size_t		count;
	size_t		capacity;
} CallSiteList;

typedef struct {
	size_t	arg_vregs[MAX_PARAMS_PER_FUNCTION];
	size_t	count;
} PendingCall;

typedef struct {
	Arena 				*data_arena;
	Arena				*exec_arena;
	FunctionRegistry	registry;
	CallSiteList		call_sites;
	PendingCall			pending_call;

	uint8_t				*label_offset[MAX_LABELS];
	bool				label_defined[MAX_LABELS];
	Patch				*patches;

	Location			*vreg_map;
	bool				phys_regs[16];
} JITContext;

bool	jit_compile_pass(JITContext *jit_ctx, CompilationContext *comp_ctx, 
					ErrorContext *errors);
void		jit_ctx_init(JITContext *ctx, Arena *a, Arena *exec_arena);
JITResult	jit_compile_function(JITContext *ctx, IRFunction *ir_func, ASTNode *func);
bool		jit_link_all(JITContext *ctx, ErrorContext *errors);

void		emit_u8(uint8_t **buf, size_t *count, uint8_t byte);
void		emit_u32(uint8_t **buf, size_t *count, uint32_t val);
void		emit_u64(uint8_t **buf, size_t *count, uint64_t val);
void		emit_store_local(uint8_t **buf, size_t *cnt, X86Reg src, int32_t disp);
void		emit_load_param(uint8_t **buf, size_t *cnt, X86Reg dst, int32_t disp);
void		emit_mov_imm(uint8_t **buf, size_t *cnt, X86Reg dst, uint64_t imm);
void		emit_alu(uint8_t **buf, size_t *cnt, X86Opcode op, X86Reg dst, X86Reg src);
void		emit_imul_r64(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src);
void        emit_mov_reg_reg(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src);
void		emit_cmp(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src);
void		emit_movzx(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src);
void		emit_setcc(uint8_t **buf, size_t *cnt, X86Condition cc, X86Reg dst);
void		emit_test(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src);

#endif


==================================================
FILE: ./incs/layout.h
==================================================
#ifndef LAYOUT_H
# define LAYOUT_H

#define RESET       "\033[0m"
#define BOLD        "\033[1m"
#define DIM         "\033[2m"
#define GREEN       "\033[0;32m"
#define BOLD_GREEN  "\033[1;32m"
#define CYAN        "\033[0;36m"
#define WHITE       "\033[0;97m"
#define BOLD_WHITE  "\033[1;97m"
#define RED			"\033[0;31m"
#define BOLD_RED	"\033[1;31m"

#define BOX_TL "╔" // Top Left
#define BOX_TR "╗" // Top Right
#define BOX_BL "╚" // Bottom Left
#define BOX_BR "╝" // Bottom Right
#define BOX_H  "═" // Horizontal
#define BOX_V  "║" // Vertical

#endif


==================================================
FILE: ./incs/lexer.h
==================================================
#ifndef LEXER_H
# define LEXER_H

# include <ctype.h>
# include <stdbool.h>
# include "file_map.h"
# include "string_view.h"

typedef enum {
	#define X_TOKEN(name, str, is_keyword, prec, prefix_fn, infix_fn, stmt_fn) name,
	#include "lexer_tokens.def"
	#undef X_TOKEN
}	TokenType;

typedef struct {
	TokenType type;
	StringView text;
	int line;
	int column;
} Token;

typedef struct {
	const char	*start;
	const char	*curr;
	const char	*end;
	int 		line;
	int 		column;
	FileMap		*file;
} Lexer;

/* =================== */
/* FUNCTION PROTOTYPES */
/* =================== */

void	lexer_init(Lexer *l, FileMap *file);
Token	lexer_next(Lexer *l);
char	lexer_peek(Lexer *l);
char	lexer_peek_next(Lexer *l);
char	lexer_advance(Lexer *l);
void	lexer_skip_whitespace(Lexer *l);
Token	lexer_make_token(Lexer *l, TokenType type, StringView text);
Token	lexer_make_token_no_sv(Lexer *l, TokenType type);

#endif


==================================================
FILE: ./incs/memarena.h
==================================================
/*
   ----------------------------------------------------------------------------
   MEMARENA.H v1.0.0
   ----------------------------------------------------------------------------
   Growing memory arena using mmap and linked lists with ASAN support.
   
   Author:  Juuso Rinta
   Repo:    github.com/juusokasperi/memarena
   License: MIT
   ----------------------------------------------------------------------------
   
   USAGE:
     Define MEMARENA_IMPLEMENTATION in *one* .c file before including this:
     
     #define MEMARENA_IMPLEMENTATION
     #include "memarena.h"

	 In all other files, just #include "memarena.h" as per normal.
*/

#ifndef MEMARENA_H
# define MEMARENA_H

# include <stdio.h>
# include <stdlib.h>
# include <sys/mman.h>
# include <unistd.h>
# include <string.h>
# include <stdbool.h>
# include <stdarg.h>

/* --- Versioning --- */
#define MEMARENA_VERSION_MAJOR 1
#define MEMARENA_VERSION_MINOR 0
#define MEMARENA_VERSION_PATCH 0

#define MEMARENA_STR_HELPER(x) #x
#define MEMARENA_STR(x) MEMARENA_STR_HELPER(x)
#define MEMARENA_VERSION_STRING \
    MEMARENA_STR(MEMARENA_VERSION_MAJOR) "." \
    MEMARENA_STR(MEMARENA_VERSION_MINOR) "." \
    MEMARENA_STR(MEMARENA_VERSION_PATCH)

// Helper to bundle version info
typedef struct {
	int	major;
	int	minor;
	int	patch;
} MemArenaVersion;


/* --- Configuration --- */
// To disable dynamic resizing (effectively allow only one ArenaBlock)
// #define MEMARENA_DISABLE_RESIZE	

#ifndef MEMARENA_DEFAULT_SIZE
  #define MEMARENA_DEFAULT_SIZE (64 * 1024 * 1024)
#endif

#define DEFAULT_ALIGNMENT 8
#define is_power_of_two(x) ((x != 0) && ((x & (x - 1)) == 0))

//* --- ASAN Support --- *//
#if defined(__SANITIZE_ADDRESS__) || defined(ADDRESS_SANITIZER) \
	|| (defined(__has_feature) && __has_feature(address_sanitizer))
  #include <sanitizer/asan_interface.h>
  #ifndef ASAN_POISON_MEMORY_REGION
    #define ASAN_POISON_MEMORY_REGION(addr, size) \
	  __asan_poison_memory_region((void*)(addr), (size))
  #endif

  #ifndef ASAN_UNPOISON_MEMORY_REGION 
    #define ASAN_UNPOISON_MEMORY_REGION(addr, size) \
	  __asan_unpoison_memory_region((void*)(addr), (size))
  #endif 

#else
  #define ASAN_POISON_MEMORY_REGION(addr, size)		((void)0)
  #define ASAN_UNPOISON_MEMORY_REGION(addr, size)	((void)0)
#endif 



/* --- Structs --- */
typedef struct ArenaBlock ArenaBlock;

struct ArenaBlock
{
ArenaBlock	*prev;
	size_t		size;
	size_t		offset;
};

typedef struct {
	ArenaBlock	*curr;
	int			prot;
} Arena;

typedef struct {
	ArenaBlock	*block;
	size_t		offset;
} ArenaPos;

typedef struct {
	Arena		*arena;
	ArenaPos	pos;
} ArenaTemp;

/* --- API prototypes --- */
Arena			arena_init(int prot);
void			arena_free(Arena *a);
void			arena_reset(Arena *a);

void			*arena_alloc(Arena *a, size_t size);
void			*arena_alloc_aligned(Arena *a, size_t size, size_t align);
void			*arena_alloc_zeroed(Arena *a, size_t size);

ArenaTemp		arena_temp_begin(Arena *a);
void			arena_temp_end(ArenaTemp temp);

size_t			arena_total_used(Arena *a);
bool			arena_set_prot(Arena *a, int prot);
void			arena_print_stats(Arena *a);
MemArenaVersion	get_arena_version(void);

// Sprintf that allocates to the arena
char			*arena_sprintf(Arena *a, const char *fmt, ...) __attribute__((format(printf, 2, 3)));

#endif // MEMARENA_H

/* ========================================================================= */
/* IMPLEMENTATION                                                            */
/* ========================================================================= */

#ifdef MEMARENA_IMPLEMENTATION
# ifndef MEMARENA_IMPLEMENTATION_GUARD
#  define MEMARENA_IMPLEMENTATION_GUARD

/* --- Internal static helpers --- */
// Forces the string "MEMARENA_VERSION_x.x.x" into the binary data
#ifndef NDEBUG
 static const char *volatile memarena_version_tag __attribute__((used)) = "MEMARENA_VERSION_" MEMARENA_VERSION_STRING;
#endif

static size_t get_page_size(void) {
    static size_t page_size = 0;
    if (page_size == 0)
	{
        long res = sysconf(_SC_PAGESIZE);
        page_size = (res > 0) ? (size_t)res : 4096;
    }
    return (page_size);
}

static size_t align_to_page(size_t size)
{
    size_t page_size = get_page_size();
return ((size + page_size - 1) & ~(page_size - 1));
}

static uintptr_t align_forward(uintptr_t ptr, size_t align)
{
    uintptr_t a = (uintptr_t)align;
    uintptr_t modulo = ptr & (a - 1);
    if (modulo != 0)
        ptr += a - modulo;
    return (ptr);
}

static ArenaBlock *arena_create_block(size_t capacity, int prot, ArenaBlock *prev_block) 
{
    void *hint_addr = NULL;
    if (prev_block)
        hint_addr = (void *)((char *)prev_block + prev_block->size);

    size_t total_needed = capacity + sizeof(ArenaBlock);
    size_t total_size = align_to_page(total_needed);

    void *base = mmap(hint_addr, total_size, prot, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (base == MAP_FAILED)
        return (NULL);
    
    if (prev_block && base == hint_addr)
	{
        prev_block->size += total_size;
        ASAN_POISON_MEMORY_REGION(base, total_size);
        return (prev_block);
    }

    ArenaBlock *block = (ArenaBlock *)base;
    block->prev = prev_block;
    block->size = total_size;
    block->offset = sizeof(ArenaBlock);

    ASAN_POISON_MEMORY_REGION((char *)base + sizeof(ArenaBlock), total_size - sizeof(ArenaBlock));
    return (block);
}

/* --- API Implementation --- */
Arena arena_init(int prot)
{
    Arena a = {0};
    a.prot = prot;
#ifdef MEMARENA_DISABLE_RESIZE
    a.curr = arena_create_block(MEMARENA_DEFAULT_SIZE, prot, NULL);
#endif
    return (a);
}

void arena_free(Arena *a)
{
    ArenaBlock *curr = a->curr;
    while (curr)
	{
        ArenaBlock *prev = curr->prev;
        munmap(curr, curr->size);
        curr = prev;
    }
    a->curr = NULL;
}

void arena_reset(Arena *a)
{
    if (!a->curr)
		return;
    ArenaBlock *curr = a->curr;
    while (curr->prev != NULL)
	{
        ArenaBlock *prev = curr->prev;
        munmap(curr, curr->size);
        curr = prev;
    }
    a->curr = curr;
    a->curr->offset = sizeof(ArenaBlock);
    ASAN_POISON_MEMORY_REGION((char*)a->curr + sizeof(ArenaBlock), a->curr->size - sizeof(ArenaBlock));
}

void *arena_alloc(Arena *a, size_t size)
{
    return (arena_alloc_aligned(a, size, DEFAULT_ALIGNMENT));
}

void *arena_alloc_aligned(Arena *a, size_t size, size_t align)
{
    if (size == 0)
		return (NULL);
    if (!is_power_of_two(align))
		return (NULL);

    if (a->curr == NULL)
	{
#ifdef MEMARENA_DISABLE_RESIZE
        return (NULL);
#else
        size_t block_size = (size > MEMARENA_DEFAULT_SIZE) ? size : MEMARENA_DEFAULT_SIZE;
        a->curr = arena_create_block(block_size, a->prot, NULL);
        if (!a->curr)
			return (NULL);
#endif
    }

    uintptr_t base_addr = (uintptr_t)a->curr;
    uintptr_t current_addr = base_addr + a->curr->offset;
    uintptr_t aligned_addr = align_forward(current_addr, align);
    size_t padding = aligned_addr - current_addr;

    if (a->curr->offset + padding + size > a->curr->size)
	{
#ifdef MEMARENA_DISABLE_RESIZE
        return (NULL);
#else
        size_t needed = size + align;
        size_t next_size = (needed > MEMARENA_DEFAULT_SIZE) ? needed : MEMARENA_DEFAULT_SIZE;
        ArenaBlock *new_block = arena_create_block(next_size, a->prot, a->curr);
        if (!new_block)
			return (NULL);
        
        if (new_block != a->curr)
		{
            a->curr = new_block;
            base_addr = (uintptr_t)a->curr;
            current_addr = base_addr + a->curr->offset;
            aligned_addr = align_forward(current_addr, align);
            padding = aligned_addr - current_addr;
        }
#endif
    }

    a->curr->offset += padding;
    void *ptr = (void *)(base_addr + a->curr->offset);
    ASAN_UNPOISON_MEMORY_REGION(ptr, size);
    a->curr->offset += size;

	return (ptr);
}

void *arena_alloc_zeroed(Arena *a, size_t size)
{
    void *ptr = arena_alloc(a, size);
    if (ptr)
		memset(ptr, 0, size);
    return (ptr);
}

ArenaTemp arena_temp_begin(Arena *a)
{
    ArenaTemp temp = {0};
    temp.arena = a;
    temp.pos.block = a->curr;
    temp.pos.offset = a->curr ? a->curr->offset : 0;
    return (temp);
}

void arena_temp_end(ArenaTemp temp)
{
    if (!temp.arena->curr)
		return;
    ArenaBlock *curr = temp.arena->curr;
    while (curr != temp.pos.block)
	{
        if (curr->prev == NULL)
			return;
        ArenaBlock *prev = curr->prev;
        munmap(curr, curr->size);
        curr = prev;
    }
    temp.arena->curr = temp.pos.block;
    if (temp.arena->curr)
	{
        size_t old_offset = temp.arena->curr->offset;
        temp.arena->curr->offset = temp.pos.offset;
        ASAN_POISON_MEMORY_REGION(
				(char *)temp.arena->curr + temp.pos.offset,
				old_offset - temp.pos.offset);
    	(void)old_offset;
	}
}

size_t arena_total_used(Arena *a)
{
    size_t total = 0;
    ArenaBlock *curr = a->curr;
    while (curr)
	{
        total += curr->offset;
        curr = curr->prev;
    }
    return (total);
}

bool arena_set_prot(Arena *a, int prot)
{
    ArenaBlock *curr = a->curr;
    while (curr)
	{
        if (mprotect(curr, curr->size, prot) == -1)
			return (false);
        curr = curr->prev;
    }
    a->prot = prot;
    return (true);
}

void arena_print_stats(Arena *a)
{
    size_t total_capacity = 0;
    size_t total_used = 0;
    size_t block_count = 0;

    ArenaBlock *curr = a->curr;
    while (curr)
	{
        total_capacity += curr->size;
        total_used += curr->offset;
        block_count++;
        curr = curr->prev;
    }

    printf("Arena Stats:\n");
    printf("  OS Page size: %zuKiB\n", get_page_size() / 1024);
    printf("  Blocks:   %zu\n", block_count);
    printf("  Capacity: %zu MB (%zu KiB) [%zu bytes]\n",
			total_capacity / (1024 * 1024),
			total_capacity / 1024,
			total_capacity);
    printf("  Used:     %zu MB (%zu KiB) [%zu bytes]\n",
			total_used / (1024 * 1024),
			total_used / 1024,
			total_used);
}

MemArenaVersion memarena_get_version(void)
{
    MemArenaVersion v = { 
        MEMARENA_VERSION_MAJOR, 
        MEMARENA_VERSION_MINOR, 
        MEMARENA_VERSION_PATCH 
    };
    return (v);
}

char *arena_sprintf(Arena *a, const char *fmt, ...)
{
    va_list args, args_copy;
    va_start(args, fmt);
    va_copy(args_copy, args);
	int size = vsnprintf(NULL, 0, fmt, args);
    va_end(args);

    if (size < 0)
		return (NULL);
    char *buffer = arena_alloc(a, size + 1);
    vsnprintf(buffer, size + 1, fmt, args_copy);
    va_end(args_copy);
    return (buffer);
}

#endif // MEMARENA_IMPLEMENTATION_GUARD
#endif // MEMARENA_IMPLEMENTATION


==================================================
FILE: ./incs/parser_internal.h
==================================================
#ifndef PARSER_INTERNAL_H
# define PARSER_INTERNAL_H

# include "parser.h"
# include "ast.h"
# include "lexer.h"

typedef ASTNode*	(*ParsePrefixFn)(Parser *p);
typedef ASTNode*	(*ParseInfixFn)(Parser *p, ASTNode *left);
typedef ASTNode*	(*ParseStmtFn)(Parser *p);

typedef struct {
	const char		*name;
	Precedence		prec;
	ParsePrefixFn	prefix;
	ParseInfixFn	infix;
	ParseStmtFn	stmt;
} ParseRule;

extern const ParseRule rules[];

// === Expression parsing (parser_expr.c) ===
ASTNode		*parse_expression(Parser *parser, Precedence precedence);
ASTNode		*parse_assignment(Parser *p, ASTNode *left);
ASTNode		*parse_identifier(Parser *parser);
ASTNode		*parse_grouping(Parser *parser);
ASTNode		*parse_number(Parser *parser);
ASTNode		*parse_unary(Parser *parser);
ASTNode		*parse_binary(Parser *parser, ASTNode *left);
ASTNode		*parse_call(Parser *parser, ASTNode *callee);

// === Statement parsing (parser_stmt.c) ===
ASTNode		*parse_statement(Parser *parser);
ASTNode		*parse_block(Parser *parser);
ASTNode		*parse_function(Parser *parser);
ASTNode		*parse_var_decl(Parser *parser);
ASTNode		*parse_return(Parser *parser);
ASTNode		*parse_if(Parser *parser);
ASTNode		*parse_while(Parser *parser);
ASTNode		*parse_expr_stmt(Parser *parser);

// === Utils (parser_utils.c ===
void		parser_advance(Parser *parser);
void		parser_consume(Parser *parser, TokenType type, const char *message);
void 		parser_error(Parser *parser, const char *fmt, ...);
void		parser_synchronize(Parser *parser);
bool		match(Parser *parser, TokenType type);
bool		check(Parser *parser, TokenType type);
const char	*token_type_name(TokenType type);
Precedence	get_token_precedence(TokenType type);




#endif // PARSER_INTERNAL_H


==================================================
FILE: ./incs/parser.h
==================================================
#ifndef PARSER_H
# define PARSER_H

# include "error_handler.h"
# include "lexer.h"
# include "ast.h"
# include "memarena.h"
# include "defines.h"
# include <stdbool.h>
# include <stddef.h>

typedef enum {
	PREC_NONE,
	PREC_ASSIGNMENT,	// =
	PREC_OR,			// ||
	PREC_AND,			// &&
	PREC_EQUALITY,		// == =!
	PREC_COMPARISON,	// < > <= >=
	PREC_TERM,			// + -
	PREC_FACTOR,		// * /
	PREC_UNARY,			// ! -
	PREC_CALL,			// . ()
	PREC_PRIMARY,
} Precedence;

typedef struct {
	Lexer			*lexer;
	Arena			*arena;
	ErrorContext	*errors;
	Token			current;
	Token			next;
	bool			panic_mode;
	size_t			expr_depth;
} Parser;

ASTNode	*parser_parse(Lexer *l, Arena *a, ErrorContext *e);

#endif


==================================================
FILE: ./incs/semantic.h
==================================================
#ifndef SEMANTIC_H
# define SEMANTIC_H

# include "ast.h"
# include "memarena.h"
# include "defines.h"
# include "string_view.h"
# include "error_handler.h"
# include <stdbool.h>
# include <stddef.h>

typedef struct CompilationUnit CompilationUnit;

typedef struct {
	StringView	name;
	DataType	type;
	bool		initialized;
	int			line;
} VarInfo;

typedef struct Scope Scope;

struct Scope {
	Scope	*parent;
	VarInfo	vars[MAX_VARS_PER_SCOPE];
	size_t	var_count;
};

typedef struct {
	StringView	name;
	DataType	return_type;
	Parameter	*params;
	size_t		param_count;
	int			line;
	const char	*filename;
	bool		is_prototype;
} FunctionInfo;

typedef struct {
	FunctionInfo	functions[MAX_FUNCTION_COUNT];
	size_t			function_count;
} GlobalScope;

typedef struct {
	Scope			*current;
	Arena			*arena;
	ErrorContext	*errors;
	const char		*filename;
	GlobalScope		*global;
	DataType		current_return_type;

	StringView		visible_funcs[MAX_FUNCTION_COUNT];
	size_t			visible_count;
} SemanticAnalyzer;

bool	semantic_analyze(Arena *a, CompilationUnit *unit, ErrorContext *errors, GlobalScope *global);

bool	semantic_global_declare_function(GlobalScope *global, ErrorContext *errors, 
			ASTNode *func_node, const char *filename);

FunctionInfo	*semantic_global_lookup_function(GlobalScope *global, StringView name);

Scope	*semantic_scope_enter(SemanticAnalyzer *sa);
void	semantic_scope_exit(SemanticAnalyzer *sa);
VarInfo	*semantic_scope_lookup(Scope *scope, StringView name);
bool	semantic_scope_declare(SemanticAnalyzer *sa, StringView name, DataType type, int line);

#endif


==================================================
FILE: ./incs/string_view.h
==================================================
#ifndef STRING_VIEW_H
# define STRING_VIEW_H

#include <string.h>
#include "memarena.h"

typedef struct {
	const char *start;
	size_t len;
} StringView;

/* StringView functions */
static inline bool sv_eq(StringView a, StringView b)
{
	if (a.len != b.len)
		return (false);
	return (memcmp(a.start, b.start, a.len) == 0);
}

static inline bool sv_eq_cstr(StringView sv, const char *str)
{
    return (strlen(str) == sv.len && memcmp(sv.start, str, sv.len) == 0);
}

static inline int64_t sv_to_int(Arena *a, StringView sv)
{
	ArenaTemp temp = arena_temp_begin(a);

    char *buf = arena_alloc(a, sv.len + 1);
    if (!buf)
	{
		arena_temp_end(temp);
		return (0);
	}
    
    memcpy(buf, sv.start, sv.len);
    buf[sv.len] = '\0';
    
	int64_t result = atoll(buf);
	arena_temp_end(temp);

    return result;
}


#endif // STRING_VIEW_H


==================================================
FILE: ./incs/utils.h
==================================================
#ifndef UTILS_H
# define UTILS_H

void print_header(void);
void print_phase(int step, const char *name);

#endif


==================================================
FILE: ./incs/validation.h
==================================================
#ifndef VALIDATION_H
# define VALIDATION_H

# include <stdbool.h>
# include <stddef.h>
# include <sys/stat.h>
# include <limits.h>
# include "error_handler.h"

typedef struct {
	bool	exists;
	bool	readable;
	bool	is_regular_file;
	size_t	size;
	char	canonical_path[PATH_MAX];
} FileValidation;

bool	validate_source_file(const char *filepath, FileValidation *out,
				ErrorContext *errors);
bool	validate_file_extension(const char *filepath, const char *expected_ext);
bool	validate_file_size(size_t size, size_t max_size, const char *filepath,
				ErrorContext *errors);
bool	validate_identifier(const char *name, size_t len, ErrorContext *errors,
				const char *filename, int line);
bool	validate_integer_literal(const char *text, size_t len, int64_t *out_value,
				ErrorContext *errors, const char *filename, int line);

#endif // VALIDATION_H


==================================================
FILE: ./srcs/cleanup/cleanup.c
==================================================
#include "cleanup.h"
#include <stdlib.h>
#include <string.h>

void	resource_tracker_init(ResourceTracker *tracker, size_t capacity, Arena *a)
{
	tracker->capacity = capacity;
	tracker->count = 0;
	tracker->arena = a;
	tracker->files = arena_alloc(tracker->arena, capacity * sizeof(FileResource));
}

void	resource_track_fd(ResourceTracker *tracker, int fd)
{
	// TODO improve silent failure
	if (tracker->count >= tracker->capacity)
		return;
	tracker->files[tracker->count++] = (FileResource){
		.fd = fd,
		.needs_close = true,
		.needs_munmap = false,
	};
}

void	resource_track_mmap(ResourceTracker *tracker, void *addr, size_t size)
{
	// TODO improve silent failure
	if (tracker->count >= tracker->capacity)
		return;
	tracker->files[tracker->count++] = (FileResource){
		.fd = -1,
		.addr = addr,
		.size = size,
		.needs_close = false,
		.needs_munmap = true,
	};
}

void	resource_track_file(ResourceTracker *tracker, int fd, void *addr, size_t size)
{
	// TODO improve silent failure
	if (tracker->count >= tracker->capacity)
		return;
	tracker->files[tracker->count++] = (FileResource){
		.fd = fd,
		.addr = addr,
		.size = size,
		.needs_close = true,
		.needs_munmap = true,
	};
}

void	resource_cleanup_all(ResourceTracker *tracker)
{
	for (size_t i = 0; i < tracker->count; ++i)
	{
		FileResource *res = &tracker->files[i];
		if (res->needs_munmap && res->addr)
			munmap(res->addr, res->size);
		if (res->needs_close && res->fd >= 0)
			close(res->fd);
	}
	tracker->files = NULL;
	tracker->count = 0;
}

void	resource_untrack_fd(ResourceTracker *tracker, int fd)
{
	for (size_t i = 0; i < tracker->count; ++i)
	{
		if (tracker->files[i].fd == fd)
		{
			tracker->files[i].needs_close = false;
			return;
		}
	}
}


==================================================
FILE: ./srcs/compile/compile.c
==================================================
#include "compile.h"
#include "cleanup.h"
#include "layout.h"
#include "utils.h"
#include <stdio.h>
#include "bounds.h"
#include "lexer.h"
#include "validation.h"
#include "parser.h"
#include <errno.h>
#include <fcntl.h>

bool compile_ctx_init(CompilationContext *ctx, Arena *arena, 
		ErrorContext *errors, size_t file_count)
{
	ctx->arena = arena;
	ctx->errors = errors;
	ctx->count = 0;
	if (file_count < 1)
	{
		error_fatal(errors, NULL, 0, 0,
				"Expected at least 1 source file");
		return (false);
	}
	if (file_count > MAX_SOURCE_FILES)
	{
		error_fatal(errors, NULL, 0, 0,
				"Too many files (max %d)", MAX_SOURCE_FILES);
		return (false);
	}
	ctx->capacity = file_count > 0 ? file_count : 8;
	ctx->units = arena_alloc(arena, sizeof(CompilationUnit) * ctx->capacity);
	if (!ctx->units)
	{
		error_fatal(errors, NULL, 0, 0,
				"Failed to allocate compilation units");
		return (false);
	}
	ctx->global.function_count = 0;
	return (true);
}

bool compile_ctx_add_file(CompilationContext *ctx, const char *filepath,
		ResourceTracker *resources)
{
	if (ctx->count >= ctx->capacity)
	{
		error_fatal(ctx->errors, NULL, 0, 0, "Internal error: compilation unit overflow");
		return (false);
	}
	FileValidation validation;
	if (!validate_source_file(filepath, &validation, ctx->errors))
		return (false);

	int fd = open(validation.canonical_path, O_RDONLY);
	if (fd == -1)
	{
		error_fatal(ctx->errors, filepath, 0, 0,
				"Failed to open file: %s", strerror(errno));
		return (false);
	}

	FileMap file = map_input(fd);
	if (!file.data)
	{
		error_fatal(ctx->errors, filepath, 0, 0,
				"Failed to map file into memory: %s", strerror(errno));
		return (false);
	}
	file.name = filepath;
	resource_track_mmap(resources, (void *)file.data, file.length);
	ctx->units[ctx->count] = (CompilationUnit){
		.file = file,
		.ast = NULL,
		.parsed_ok = false
	};
	ctx->count++;

	printf(BOLD_GREEN "> LOAD SOURCE: " RESET WHITE "%s (%zu bytes)\n" RESET, filepath, file.length);
	return (true);
}

bool compile_parse_all(CompilationContext *ctx)
{
	bool all_ok = true;

	for (size_t i = 0; i < ctx->count; ++i)
	{
		CompilationUnit *unit = &ctx->units[i];
		printf ("  > parsing %s\n", unit->file.name);
		Lexer lexer;
		lexer_init(&lexer, &unit->file);
		unit->ast = parser_parse(&lexer, ctx->arena, ctx->errors);
		unit->parsed_ok = (unit->ast != NULL);
		if (!unit->parsed_ok)
		{
			error_parser(ctx->errors, unit->file.name, 0, 0, "Parse failed");
			all_ok = false;
		}
	}

	return (all_ok);
}

bool compile_analyze_all(CompilationContext *ctx)
{
	bool all_ok = true;

	printf("  > collecting function declarations\n");
	for (size_t i = 0; i < ctx->count; ++i)
	{
		CompilationUnit *unit = &ctx->units[i];
		if (!unit->parsed_ok)
			continue;
		for (size_t j = 0; j < unit->ast->translation_unit.count; ++j)
		{
			ASTNode *func = unit->ast->translation_unit.declarations[j];
			if (func->type == AST_FUNCTION)
			{
				if (!semantic_global_declare_function(&ctx->global, 
							ctx->errors, func, unit->file.name))
					all_ok = false;
			}
		}
	}
	if (!all_ok)
		return (false);
	
	printf("  > analyzing function bodies\n");
	for (size_t i = 0; i < ctx->count; ++i)
	{
		CompilationUnit *unit = &ctx->units[i];
		if (!unit->parsed_ok || !unit->ast)
			continue;
		printf("%4zu | %s\n", i, unit->file.name);
		if (!semantic_analyze(ctx->arena, unit, ctx->errors, &ctx->global))
			all_ok = false;
	}

	return (all_ok);
}

ASTNode *compile_get_entry_point(CompilationContext *ctx)
{
	for (size_t i = 0; i < ctx->count; ++i)
	{
		CompilationUnit *unit = &ctx->units[i];
		if (!unit->ast || !unit->parsed_ok)
			continue;
		for (size_t j = 0; j < unit->ast->translation_unit.count; ++j)
		{
			ASTNode *func = unit->ast->translation_unit.declarations[j];
			if (func->type == AST_FUNCTION && sv_eq_cstr(func->function.name, "main"))
				return (func);
		}
	}

	error_fatal(ctx->errors, NULL, 0, 0, "No main() function found");
	return (NULL);
}


==================================================
FILE: ./srcs/error_handler/error_handler.c
==================================================
#include "error_handler.h"
#include "layout.h"
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

static const char	*category_names[] = {
	"lexer",
	"parser",
	"semantic",
	"codegen",
	"system"
};

static const char	*level_colors[] = {
	BOLD_GREEN,
	BOLD_RED,
	BOLD_RED
};

static const char	*level_names[] = {
	"warning",
	"error",
	"fatal error"
};

void	error_context_init(ErrorContext *ctx, Arena *arena)
{
	ctx->head = NULL;
	ctx->tail = NULL;
	ctx->error_count = 0;
	ctx->warning_count = 0;
	ctx->arena = arena;
}

void error_add(ErrorContext *ctx, ErrorCategory category, ErrorLevel level,
				const char *filename, int line, int column,
				const char *fmt, ...)
{
	va_list	args;
	va_start(args, fmt);
	char buffer[1024];
	vsnprintf(buffer, sizeof(buffer), fmt, args);
	va_end(args);

	size_t len = strlen(buffer);
	char *msg = arena_alloc(ctx->arena, len + 1);
	memcpy(msg, buffer, len + 1);
	ErrorNode *node = arena_alloc(ctx->arena, sizeof(ErrorNode));
	node->category = category;
	node->level = level;
	node->message = msg;
	node->filename = filename;
	node->line = line;
	node->column = column;
	node->next = NULL;

	if (ctx->tail)
	{
		ctx->tail->next = node;
		ctx->tail = node;
	}
	else
		ctx->head = ctx->tail = node;
	
	if (level == ERROR_LEVEL_WARNING)
		ctx->warning_count++;
	else
		ctx->error_count++;
}

bool	error_has_errors(ErrorContext *ctx)
{
	return (ctx->error_count > 0);
}

bool	error_has_fatal(ErrorContext *ctx)
{
	ErrorNode	*curr = ctx->head;
	while (curr)
	{
		if (curr->level == ERROR_LEVEL_FATAL)
			return (true);
		curr = curr->next;
	}
	return (false);
}

void	error_print_all(ErrorContext *ctx)
{
	if (!ctx->head)
		return;
	fprintf(stderr, "\n");
	fprintf(stderr, BOLD_WHITE "Compilation failed with %zu error(s) and %zu warning(s)\n" RESET,
        ctx->error_count, ctx->warning_count);
	fprintf(stderr, "\n");

	ErrorNode	*curr = ctx->head;
	while (curr)
	{
		const char	*color = level_colors[curr->level];
		const char	*level_name = level_names[curr->level];
		if (curr->filename)
		{
			fprintf(stderr, "%s%s:%d:%d: %s[%s]%s %s\n" RESET, BOLD_WHITE,
					curr->filename, curr->line, curr->column, color, level_name,
					RESET, curr->message);
		}
		else
		{
			fprintf(stderr, "%s%s[%s]%s %s\n" RESET, color, category_names[curr->category],
					level_name, RESET, curr->message);
		}
		curr = curr->next;
	}
}


==================================================
FILE: ./srcs/ir/ir_gen.c
==================================================
#include "ast.h"
#include "ir.h"
#include <stddef.h>
#include <stdlib.h>

static size_t	gen_expression(Arena *a, IRFunction *f,
		ASTNode *node, SymbolTable *symbol_table);
static void		gen_statement(Arena *a, IRFunction *f, 
		ASTNode *node, SymbolTable *symbol_table, size_t *last_reg);


static void emit(Arena *a, IRFunction *f, IRInstruction inst)
{
	if (f->tail == NULL || f->tail->count >= IR_CHUNK_SIZE)
	{
		IRChunk *new_chunk = arena_alloc(a, sizeof(IRChunk));
		*new_chunk = (IRChunk){0};
		if (f->tail)
			f->tail->next = new_chunk;
		else
			f->head = new_chunk;
		f->tail = new_chunk;
	}

	f->tail->instructions[f->tail->count] = inst;
	f->tail->count++;
	f->total_count++;
}

static size_t gen_number(Arena *a, IRFunction *f, ASTNode *node)
{
	size_t reg = IR_NEXT_VREG(f);
	int64_t val = sv_to_int(a, node->number.value);
	IRInstruction inst = { .opcode = IR_CONST, .dest = reg, .imm = val };
	emit(a, f, inst);
	return (reg);
}

static size_t gen_identifier(ASTNode *node, SymbolTable *symbol_table)
{
	Symbol *sym = symbol_table_lookup(symbol_table, node->identifier.name);
	return (sym ? sym->vreg : 0);
}

static size_t gen_call(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table)
{
	size_t	arg_vregs[MAX_PARAMS_PER_FUNCTION];
	size_t	result_reg;

	for (size_t i = 0; i < node->call.arg_count; ++i)
		arg_vregs[i] = gen_expression(a, f, node->call.args[i], symbol_table);

	for (size_t i = 0; i < node->call.arg_count; ++i)
	{
		IRInstruction arg_inst = { 
			.opcode = IR_ARG,
			.src_1 = arg_vregs[i],
			.imm = i
		};
		emit(a, f, arg_inst);
	}
	result_reg = IR_NEXT_VREG(f);
	IRInstruction call_inst = {
		.opcode = IR_CALL,
		.dest = result_reg,
		.func_name = node->call.function_name
	};
	emit(a, f, call_inst);
	return (result_reg);
}

static size_t gen_unary(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table)
{
	size_t		operand;
	size_t		dest;
	IROpcode	op;

	operand = gen_expression(a, f, node->unary.operand, symbol_table);
	dest = IR_NEXT_VREG(f);
	op = (node->type == AST_NOT) ? IR_NOT : IR_NEG;
	emit(a, f, (IRInstruction){ .opcode = op, .dest = dest, .src_1 = operand });
	return (dest);
}

static size_t gen_binary_op(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table)
{
	size_t		left = gen_expression(a, f, node->binary.left, symbol_table);
	size_t		right = gen_expression(a, f, node->binary.right, symbol_table);
	size_t		dest = IR_NEXT_VREG(f);
	IROpcode	op;

	switch (node->type)
	{
		case AST_ADD:			op = IR_ADD; break;
		case AST_SUB:			op = IR_SUB; break;
		case AST_MUL:			op = IR_MUL; break;
		case AST_DIV:			op = IR_DIV; break;
		case AST_EQUAL:			op = IR_EQ; break;
        case AST_NOT_EQUAL:		op = IR_NEQ; break;
        case AST_LESS:			op = IR_LT; break;
        case AST_LESS_EQUAL:	op = IR_LE; break;
        case AST_GREATER:		op = IR_GT; break;
		case AST_GREATER_EQUAL:	op = IR_GE; break;
		default:				op = IR_ADD; break;
	}
	IRInstruction inst = {
		.opcode = op,
		.type = TYPE_INT64,		// TODO Remove default
		.dest = dest,
		.src_1 = left,
		.src_2 = right };
	emit(a, f, inst);
	return (dest);
}

static size_t gen_expression(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table)
{
	if (!node)
		return (0);

	switch (node->type)
	{
		case AST_NUMBER:
			return (gen_number(a, f, node));
		case AST_IDENTIFIER:
			return (gen_identifier(node, symbol_table));
		case AST_CALL:
			return (gen_call(a, f, node, symbol_table));
		case AST_NEGATE:
		case AST_NOT:
			return (gen_unary(a, f, node, symbol_table));
		case AST_ADD:
		case AST_SUB:
		case AST_MUL:
		case AST_DIV:
        case AST_EQUAL:
        case AST_NOT_EQUAL:
        case AST_LESS:
        case AST_LESS_EQUAL:
        case AST_GREATER:
        case AST_GREATER_EQUAL:
			return (gen_binary_op(a, f, node, symbol_table));
		case AST_VAR_DECL:
        case AST_ASSIGNMENT:
        case AST_RETURN:
        case AST_IF:
        case AST_WHILE:
        case AST_BLOCK:
        case AST_FUNCTION:
        case AST_TRANSLATION_UNIT:
			fprintf(stderr, "Internal error: statement in expression context\n");
            return (0);
	}
}

static void gen_if(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table, size_t *last_reg)
{
	if (node->if_stmt.else_branch)
	{
		size_t	label_else = f->label_count++;
		size_t	label_end = f->label_count++;
		size_t	cond_reg = gen_expression(a, f, node->if_stmt.condition, symbol_table);

		emit(a, f, (IRInstruction){ .opcode = IR_JZ, .src_1 = cond_reg, .label_id = label_else });
		gen_statement(a, f, node->if_stmt.then_branch, symbol_table, last_reg);
		emit(a, f, (IRInstruction){ .opcode = IR_JMP, .label_id = label_end });
		emit(a, f, (IRInstruction){ .opcode = IR_LABEL, .label_id = label_else });
		if (node->if_stmt.else_branch)
			gen_statement(a, f, node->if_stmt.else_branch, symbol_table, last_reg);
		emit(a, f, (IRInstruction){ .opcode = IR_LABEL, .label_id = label_end });
	}
	else
	{
		size_t	label_end = f->label_count++;
		size_t	cond_reg = gen_expression(a, f, node->if_stmt.condition, symbol_table);
		emit(a, f, (IRInstruction){ .opcode = IR_JZ, .src_1 = cond_reg, .label_id = label_end });
		gen_statement(a, f, node->if_stmt.then_branch, symbol_table, last_reg);
		emit(a, f, (IRInstruction) { .opcode = IR_LABEL, .label_id = label_end });
	}
	
}

static void	gen_while(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table, size_t *last_reg)
{
	size_t	label_start = f->label_count++;
	size_t	label_end = f->label_count++;
	size_t	cond_reg;

	emit(a, f, (IRInstruction){ .opcode = IR_LABEL, .label_id = label_start });
	cond_reg = gen_expression(a, f, node->while_stmt.condition, symbol_table);
	emit(a, f, (IRInstruction){ .opcode = IR_JZ, .src_1 = cond_reg, .label_id = label_end });
	gen_statement(a, f, node->while_stmt.body, symbol_table, last_reg);
	emit(a, f, (IRInstruction){ .opcode = IR_JMP, .label_id = label_start });
	emit(a, f, (IRInstruction){ .opcode = IR_LABEL, .label_id = label_end });
}

static void gen_var_decl(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table, size_t *last_reg)
{
	size_t	init_reg;

	if (node->var_decl.initializer)
		init_reg = gen_expression(a, f, node->var_decl.initializer, symbol_table);
	else
	{
		init_reg = IR_NEXT_VREG(f);
		IRInstruction inst = { .opcode = IR_CONST, .dest = init_reg, .imm = 0 };
		emit(a, f, inst);
	}
	symbol_table_add(symbol_table, node->var_decl.var_name, init_reg);
	*last_reg = init_reg;
}

static void gen_assignment(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table, size_t *last_reg)
{
	Symbol *sym = symbol_table_lookup(symbol_table, node->assignment.var_name);
	if (!sym)
	{
		fprintf(stderr, "Error: Assignment to undefined variable\n");
		return;
	}
	size_t val_reg = gen_expression(a, f, node->assignment.value, symbol_table);
	IRInstruction mov = { 
        .opcode = IR_MOV, 
        .dest = sym->vreg,
        .src_1 = val_reg
    };
	emit(a, f, mov);
	*last_reg = sym->vreg;
}

static void gen_return(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table)
{
	size_t ret_reg = gen_expression(a, f, node->return_stmt.expression, symbol_table);
	emit(a, f, (IRInstruction){ .opcode = IR_RET, .src_1 = ret_reg });
}

static void gen_block(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table, size_t *last_reg)
{
	ScopeChange	*watermark = symbol_table->changes;

	for (size_t i = 0; i < node->block.count; ++i)
		gen_statement(a, f, node->block.statements[i], symbol_table, last_reg);
	symbol_table_restore(symbol_table, watermark);
}

static void gen_statement(Arena *a, IRFunction *f, ASTNode *node, SymbolTable *symbol_table, size_t *last_reg)
{
	if (!node)
		return;
	switch (node->type)
	{
		case AST_VAR_DECL:
			gen_var_decl(a, f, node, symbol_table, last_reg);
			break;
		case AST_ASSIGNMENT:
			gen_assignment(a, f, node, symbol_table, last_reg);
			break;
		case AST_RETURN:
			gen_return(a, f, node, symbol_table);
			break;
		case AST_BLOCK:
			gen_block(a, f, node, symbol_table, last_reg);
			break;
		case AST_IF:
			gen_if(a, f, node, symbol_table, last_reg);
			break;
		case AST_WHILE:
			gen_while(a, f, node, symbol_table, last_reg);
			break;
		default:
			*last_reg = gen_expression(a, f, node, symbol_table);
			break;
	}
}

IRFunction *ir_gen(Arena *a, ASTNode *root)
{
	if (!root)
		return (NULL);

	IRFunction *f = arena_alloc(a, sizeof(IRFunction));
	f->vreg_count = 0;
	f->label_count = 0;
	f->total_count = 0;
	f->head = NULL;
	f->tail = NULL;

	SymbolTable symbol_table = { .arena = a, .changes = NULL };
	size_t result_reg = 0;

	if (root->type == AST_FUNCTION)
	{
		f->name = root->function.name;
		for (size_t i = 0; i < root->function.param_count; ++i)
		{
            Parameter *param = &root->function.params[i];
            size_t vreg = IR_NEXT_VREG(f);
            symbol_table_add(&symbol_table, param->name, vreg);
        }
		ASTNode *body = root->function.body;
		if (body && body->type == AST_BLOCK)
		{
			for (size_t i = 0; i < body->block.count; ++i)
			{
				gen_statement(a, f, body->block.statements[i], &symbol_table, &result_reg);
			}
		}
	}
	else if (root->type == AST_BLOCK)
	{
		for (size_t i = 0; i < root->block.count; ++i)
			gen_statement(a, f, root->block.statements[i], &symbol_table, &result_reg);
	}
	else
	{
		result_reg = gen_expression(a, f, root, &symbol_table);
		IRInstruction ret = { .opcode = IR_RET, .src_1 = result_reg };
		emit(a, f, ret);
	}
	return (f);
}


==================================================
FILE: ./srcs/ir/ir_print.c
==================================================
#include "ir.h"
#include <stdio.h>
#include "layout.h"

#define INST_BUF_SIZE 128

static void	print_jit_ir_box_start(void);
static void	print_jit_ir_line(size_t line_num, const char* instruction);
static void	print_jit_ir_box_end(void);

// 1. Generate name table
static const char	*opcode_names[] =
{
	#define X_OP(opcode, name, fmt, encoder) name,
	#include "ir_ops.def"
	#undef X_OP
};

// 2. Generate format table
static const IROpcodeFormat	opcode_formats[] =
{
	#define X_OP(opcode, name, fmt, encoder) fmt,
	#include "ir_ops.def"
	#undef X_OP
};

const char	*ir_opcode_name(IROpcode op)
{
	return (opcode_names[op]);
}

IROpcodeFormat	ir_opcode_format(IROpcode op)
{
	return (opcode_formats[op]);
}

static void	format_instruction(char *buf, size_t buf_size, IRInstruction *inst)
{
	IROpcodeFormat	fmt = ir_opcode_format(inst->opcode);
	const char		*name = ir_opcode_name(inst->opcode);
	
	switch (fmt)
	{
		case FMT_BIN:
			snprintf(buf, buf_size, "%%v%zu = %s %%v%zu, %%v%zu",
				inst->dest, name, inst->src_1, inst->src_2);
			break;
		case FMT_UNARY:
			if (inst->opcode == IR_RET)
				snprintf(buf, buf_size, "%s %%v%zu", name, inst->src_1);
			else
				snprintf(buf, buf_size, "%%v%zu = %s %%v%zu",
					inst->dest, name, inst->src_1);
			break;
		case FMT_IMM:
			snprintf(buf, buf_size, "%%v%zu = %s %lld",
				inst->dest, name, inst->imm);
			break;
		case FMT_ARG:
			snprintf(buf, buf_size, "%s %lld = %%v%zu",
				name, inst->imm, inst->src_1);
			break;
		case FMT_CALL:
			snprintf(buf, buf_size, "%%v%zu = %s %.*s",
				inst->dest, name, (int)inst->func_name.len, inst->func_name.start);
			break;
		case FMT_LABEL:
			snprintf(buf, buf_size, "L%zu:", inst->label_id);
			break;
		case FMT_JUMP:
			snprintf(buf, buf_size, "%s L%zu", name, inst->label_id);
			break;
		case FMT_BRANCH:
			snprintf(buf, buf_size, "%s %%v%zu, L%zu", name, inst->src_1, inst->label_id);
			break;
		default:
			snprintf(buf, buf_size, "UNKNOWN(%d)", inst->opcode);
			break;
	}
}

void ir_print(IRFunction *f)
{
	if (!f)
		return;
	print_jit_ir_box_start();
	IRChunk *curr = f->head;
	int idx = 0;
	char buffer[INST_BUF_SIZE];

	while (curr)
	{
		for (size_t i = 0; i < curr->count; ++i)
		{
			format_instruction(buffer, INST_BUF_SIZE, &curr->instructions[i]);
			print_jit_ir_line(idx, buffer);
			idx++;
		}
		curr = curr->next;
	}
	print_jit_ir_box_end();
}

static void print_jit_ir_box_start(void)
{
	char *text = " IR DUMP ";
	size_t len = strlen(text);

    printf("\n  " CYAN BOX_TL);
    printf(BOX_H);
	printf("%s", text);
	for (size_t i = 0; i < 39 - len - 1; ++i)
		printf(BOX_H);
    printf(BOX_TR RESET "\n");
}

static void print_jit_ir_line(size_t line_num, const char* instruction)
{
    printf("  " CYAN BOX_V RESET " %04zu | %-30s " CYAN BOX_V RESET "\n", line_num, instruction);
}

static void print_jit_ir_box_end(void)
{
    printf("  " CYAN BOX_BL);
    for (int i = 0; i < 39; ++i)
		printf(BOX_H);
    printf(BOX_BR RESET "\n");
}


==================================================
FILE: ./srcs/ir/ir_symboltable.c
==================================================
#include "defines.h"
#include "ir.h"
#include "string_view.h"
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

static uint32_t	hash_sv(StringView sv)
{
	uint32_t	hash = 2166136261u;

	for (size_t i = 0; i < sv.len; ++i)
	{
		hash ^= sv.start[i];
		hash *= 16777619;
	}
	return (hash);
}

Symbol *symbol_table_lookup(SymbolTable *st, StringView name)
{
	uint32_t	hash = hash_sv(name);
	uint32_t	idx = hash & (SYMBOL_TABLE_SIZE - 1);
	size_t		curr;

	for (size_t i = 0; i < SYMBOL_TABLE_SIZE; ++i)
	{
		curr = (idx + i) & (SYMBOL_TABLE_SIZE - 1);
		if (!st->entries[curr].occupied)
			return (NULL);
		if (sv_eq(st->entries[curr].name, name))
			return (&st->entries[curr]);
	}
	return (NULL);
}

void symbol_table_add(SymbolTable *st, StringView name, size_t vreg)
{
	uint32_t	hash = hash_sv(name);
	uint32_t	idx = hash & (SYMBOL_TABLE_SIZE - 1);
	size_t		curr;

	for (size_t i = 0; i < SYMBOL_TABLE_SIZE; ++i)
	{
		curr = (idx + i) & (SYMBOL_TABLE_SIZE - 1);
		if (!st->entries[curr].occupied 
			|| sv_eq(st->entries[curr].name, name))
		{
			ScopeChange	*change = arena_alloc(st->arena, sizeof(ScopeChange));
			if (!change)
			{
				fprintf(stderr, 
						"Fatal: out of memory in symbol_table_add\n");
				exit(1);
			}
			change->index = curr;
			change->previous = st->entries[curr];
			change->next = st->changes;
			st->changes = change;
			st->entries[curr].name = name;
			st->entries[curr].vreg = vreg;
			st->entries[curr].occupied = true;
			return;
		}
	}
	fprintf(stderr, "Fatal: Symbol table overflow (increase SYMBOL_TABLE_SIZE)\n");
	exit(1);
}

void symbol_table_restore(SymbolTable *st, ScopeChange *target_state)
{
	while (st->changes != target_state)
	{
		ScopeChange *top = st->changes;
		st->entries[top->index] = top->previous;
		st->changes = top->next;
	}
}


==================================================
FILE: ./srcs/jit/emit.c
==================================================
#include "ir.h"
#include "jit.h"
#include "jit_internal.h"
#include <stddef.h>
#include <stdint.h>
#include <unistd.h>

static uint8_t get_rex(X86Reg dst, X86Reg src)
{
	uint8_t	rex = REX_W;
	if (src >= 8)
		rex |= 0x04;
	if (dst >= 8)
		rex |= 0x01;
	return (rex);
}

void emit_u8(uint8_t **buf, size_t *count, uint8_t byte)
{
	if (buf && *buf)
	{
		**buf = byte;
		(*buf)++;
	}
	(*count)++;
}

void emit_u32(uint8_t **buf, size_t *count, uint32_t val)
{
	emit_u8(buf, count, val & 0xFF);
	emit_u8(buf, count, (val >> 8) & 0xFF);
	emit_u8(buf, count, (val >> 16) & 0xFF);
	emit_u8(buf, count, (val >> 24) & 0xFF);
}

void emit_u64(uint8_t **buf, size_t *count, uint64_t val)
{
	emit_u32(buf, count, val & 0xFFFFFFFF);
	emit_u32(buf, count, (val >> 32) & 0xFFFFFFFF);
}

// 1. Move Register -> Memory (Store)
// "mov [rbp + disp], reg"
void emit_store_local(uint8_t **buf, size_t *cnt, X86Reg src, int32_t disp)
{
	uint8_t	rex = get_rex(0, src);

    emit_u8(buf, cnt, rex);
    emit_u8(buf, cnt, MOV_RM_R); // 0x89
    // ModR/M: Mode=DISP32 (0x80) | Reg=src | RM=RBP (5)
    emit_u8(buf, cnt, MOD_MEM_DISP32 | ((src & 7) << 3) | REG_RBP);
    emit_u32(buf, cnt, disp);
}

// 2. Move Memory -> Register (Load)
// "mov reg, [rbp + disp]"
void emit_load_param(uint8_t **buf, size_t *cnt, X86Reg dst, int32_t disp)
{
	uint8_t	rex = get_rex(0, dst);

    emit_u8(buf, cnt, rex);
    emit_u8(buf, cnt, MOV_R_RM); // 0x8B
    // ModR/M: Mode=DISP32 (0x80) | Reg=dst | RM=RBP (5)
    emit_u8(buf, cnt, MOD_MEM_DISP32 | ((dst & 7) << 3) | REG_RBP);
    emit_u32(buf, cnt, disp);
}

// 3. Move Immediate -> Register
// "mov reg, 12345"
void emit_mov_imm(uint8_t **buf, size_t *cnt, X86Reg dst, uint64_t imm)
{
	uint8_t	rex = get_rex(dst, 0);

    emit_u8(buf, cnt, rex);
    emit_u8(buf, cnt, MOV_IMM_R + (dst & 7)); // 0xB8 + reg
    emit_u64(buf, cnt, imm);
}

// 4. Standard ALU (Add, Sub, Xor, etc.)
// "add dst, src"
void emit_alu(uint8_t **buf, size_t *cnt, X86Opcode op, X86Reg dst, X86Reg src)
{
	uint8_t	rex = get_rex(dst, src);

    emit_u8(buf, cnt, rex);
    emit_u8(buf, cnt, op); // e.g., ALU_ADD (0x01)
    // ModR/M: Mode=REG (0xC0) | Reg=src | RM=dst
    emit_u8(buf, cnt, MOD_REG | ((src & 7) << 3) | (dst & 7));
}

void emit_imul_r64(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src)
{
	uint8_t	rex = get_rex(src, dst);

    emit_u8(buf, cnt, rex);
    emit_u8(buf, cnt, OP_IMUL_1);
    emit_u8(buf, cnt, OP_IMUL_2);
    emit_u8(buf, cnt, MOD_REG | ((dst & 7) << 3) | (src & 7));
}

// Move register to register
// "mov dst, src"
void emit_mov_reg_reg(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src)
{
    uint8_t	rex = get_rex(dst, src);

    emit_u8(buf, cnt, rex);
    emit_u8(buf, cnt, MOV_RM_R);
    emit_u8(buf, cnt, MOD_REG | ((src & 7) << 3) | (dst & 7));
}

void emit_cmp(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src)
{
	uint8_t	rex = get_rex(dst, src);

	emit_u8(buf, cnt, rex);
	emit_u8(buf, cnt, ALU_CMP);
	emit_u8(buf, cnt, MOD_REG | ((src & 7) << 3) | (dst & 7));
}

void emit_setcc(uint8_t **buf, size_t *cnt, X86Condition cc, X86Reg dst)
{
	uint8_t	rex;

	if (dst >= 8 || (dst >= 4 && dst <= 7))
	{
		rex = 0x40;
		if (dst >= 8)
			rex |= 0x01;
		emit_u8(buf, cnt, rex);
	}
	emit_u8(buf, cnt, OP_PREFIX_0F);
	emit_u8(buf, cnt, 0x90 | cc);
	emit_u8(buf, cnt, MOD_REG | (0 << 3) | (dst & 7));
}

void emit_movzx(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src)
{
	uint8_t	rex = REX_W;

	if (dst >= 8)
		rex |= 0x04;
	if (src >= 8)
		rex |= 0x01;
	emit_u8(buf, cnt, rex);
	emit_u8(buf, cnt, OP_PREFIX_0F);
	emit_u8(buf, cnt, OP_MOVZX);
	emit_u8(buf, cnt, MOD_REG | ((dst & 7) << 3) | (src & 7));
}

void	emit_test(uint8_t **buf, size_t *cnt, X86Reg dst, X86Reg src)
{
	uint8_t rex = get_rex(dst, src);

	emit_u8(buf, cnt, rex);
	emit_u8(buf, cnt, ALU_TEST);
	emit_u8(buf, cnt, MOD_REG | ((src & 7) << 3) | (dst & 7));
}



==================================================
FILE: ./srcs/jit/encoders.c
==================================================
#include "ir.h"
#include "jit.h"
#include "jit_internal.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

static void	patch_jump_offset(uint8_t *loc, uint8_t *target)
{
	int32_t	rel = (int32_t)(target - (loc + 4));
	memcpy(loc, &rel, sizeof(int32_t));
}

/* --- Private Helper for Standard ALU Ops --- */
static inline size_t		emit_bin_op_std(uint8_t *buf, IRInstruction *inst,
				JITContext *ctx, X86Opcode opcode)
{
	uint8_t	*curr = buf;
	size_t	size = 0;

	Location dest = get_location(ctx, inst->dest);
	Location src_1 = get_location(ctx, inst->src_1);
	Location src_2 = get_location(ctx, inst->src_2);

	X86Reg working_reg = REG_RAX;
	if (src_1.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, working_reg, src_1.reg);
	else
	 	emit_load_param(&curr, &size, working_reg, src_1.offset);
	if (src_2.type == LOC_REG)
		emit_alu(&curr, &size, opcode, working_reg, src_2.reg);
	else
	{
		emit_load_param(&curr, &size, REG_RDX, src_2.offset);
		emit_alu(&curr, &size, opcode, working_reg, REG_RDX);
	}
	if (dest.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, working_reg);
	else
		emit_store_local(&curr, &size, working_reg, dest.offset);

	return (size);
}

static inline size_t emit_jump(uint8_t *buf, size_t label_id, JITContext *ctx, uint8_t opcode)
{
	uint8_t	*curr = buf;
	size_t	size = 0;

	if (opcode == OP_JMP_REL32)
		emit_u8(&curr, &size, OP_JMP_REL32);
	else
	{
		emit_u8(&curr, &size, OP_PREFIX_0F);
		emit_u8(&curr, &size, opcode);
	}

	if (!buf)
		return (size + 4);
	if (label_id < MAX_LABELS && ctx->label_defined[label_id])
	{
		uint8_t	*target = ctx->label_offset[label_id];
		int32_t rel = (int32_t)(target - (curr + 4));
		emit_u32(&curr, &size, (uint32_t)rel);
	}
	else
	{
		Patch *p = arena_alloc(ctx->data_arena, sizeof(Patch));
		p->label_id = label_id;
		p->loc = curr;
		p->next = ctx->patches;
		ctx->patches = p;
		emit_u32(&curr, &size, 0);
		return (size);
	}

	return (size);
}

static inline void	emit_jz_jnz(uint8_t **buf, size_t *size, JITContext *ctx, IRInstruction *inst)
{
	Location src = get_location(ctx, inst->src_1);
	if (src.type == LOC_REG)
		emit_test(buf, size, src.reg, src.reg);
	else
	{
		emit_load_param(buf, size, REG_RAX, src.offset);
		emit_u8(buf, size, REX_W);
		emit_u8(buf, size, ALU_IMM8);
		emit_u8(buf, size, MOD_REG | (EXT_CMP << 3) | REG_RAX);
		emit_u8(buf, size, 0x00);
	}
}

/* =============================== */
/* INDIVIDUAL INSTRUCTION ENCODERS */
/* =============================== */

size_t encode_mov(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
    (void)cnt;
    uint8_t	*curr = buf;
    size_t	size = 0;
	Location dest = get_location(ctx, inst->dest);
	Location src = get_location(ctx, inst->src_1);

	if (dest.type == LOC_REG && src.type == LOC_REG && dest.reg == src.reg)
		return (0);
    if (dest.type == LOC_REG && src.type == LOC_REG)
        emit_mov_reg_reg(&curr, &size, dest.reg, src.reg);
    else if (dest.type == LOC_REG && src.type == LOC_STACK)
        emit_load_param(&curr, &size, dest.reg, src.offset);
    else if (dest.type == LOC_STACK && src.type == LOC_REG)
        emit_store_local(&curr, &size, src.reg, dest.offset);
    else
    {
        emit_load_param(&curr, &size, REG_RAX, src.offset);
        emit_store_local(&curr, &size, REG_RAX, dest.offset);
    }

    return (size);
}

size_t	encode_cmp(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)ctx;
	(void)cnt;
	uint8_t	*curr = buf;
	size_t	size = 0;
	Location dest = get_location(ctx, inst->dest);
	Location src_1 = get_location(ctx, inst->src_1);
	Location src_2 = get_location(ctx, inst->src_2);
	X86Condition cc = CC_E;

	if (src_1.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, REG_RAX, src_1.reg);
	else
		emit_load_param(&curr, &size, REG_RAX, src_1.offset);

	X86Reg operand = REG_RCX;
	if (src_2.type == LOC_REG)
		operand = src_2.reg;
	else
		emit_load_param(&curr, &size, REG_RCX, src_2.offset);
	emit_cmp(&curr, &size, REG_RAX, operand);
	switch (inst->opcode)
	{
		case IR_EQ:		cc = CC_E; break;
		case IR_NEQ:	cc = CC_NE; break;
		case IR_LT:		cc = CC_L; break;
		case IR_LE:		cc = CC_LE; break;
		case IR_GT:		cc = CC_G; break;
		case IR_GE:		cc = CC_GE; break;
		default: break;
	}
	emit_setcc(&curr, &size, cc, REG_RAX);
	emit_movzx(&curr, &size, REG_RAX, REG_RAX);
	if (dest.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, REG_RAX);
	else
		emit_store_local(&curr, &size, REG_RAX, dest.offset);
	return (size);
}

size_t	encode_jmp(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	return (emit_jump(buf, inst->label_id, ctx, OP_JMP_REL32));
}

// JZ, JNZ
size_t	encode_branch(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t	*curr = buf;
	size_t	size = 0;
	size_t	jmp_size;
	uint8_t	opcode;

	emit_jz_jnz(&curr, &size, ctx, inst);
	opcode = 0x80 | ((inst->opcode == IR_JZ) ? CC_E : CC_NE);
	jmp_size = emit_jump(curr, inst->label_id, ctx, opcode);
	return (size + jmp_size);
}

size_t encode_label(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	size_t	id = inst->label_id;
	if (id >= MAX_LABELS)
		return (0);
	if (buf)
	{
		ctx->label_defined[id] = true;
		ctx->label_offset[id] = buf;
		Patch *p = ctx->patches;
		Patch *prev = NULL;
		while (p)
		{
			if (p->label_id == id)
			{
				patch_jump_offset(p->loc, buf);
				Patch *next = p->next;
				if (prev)
					prev->next = next;
				else
					ctx->patches = next;
				p = next;
			}
			else
			{
				prev = p;
				p = p->next;
			}
		}
	}
	return (0);
}

size_t	encode_const(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t	*curr = buf;
	size_t	size = 0;
	Location	dest = get_location(ctx, inst->dest);

	emit_mov_imm(&curr, &size, REG_RAX, inst->imm);
	if (dest.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, REG_RAX);
	else
		emit_store_local(&curr, &size, REG_RAX, dest.offset);
	return (size);
}

size_t	encode_add(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	return (emit_bin_op_std(buf, inst, ctx, ALU_ADD));
}

size_t	encode_sub(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	return (emit_bin_op_std(buf, inst, ctx, ALU_SUB));
}

size_t	encode_mul(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t		*curr = buf;
	size_t		size = 0;
	Location	dest = get_location(ctx, inst->dest);
	Location	src_1 = get_location(ctx,inst->src_1);
	Location	src_2 = get_location(ctx, inst->src_2);

	if (src_1.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, REG_RAX, src_1.reg);
	else
	 	emit_load_param(&curr, &size, REG_RAX, src_1.offset);

	X86Reg operand = REG_RCX;
	if (src_2.type == LOC_REG)
		operand = src_2.reg;
	else
	 	emit_load_param(&curr, &size, REG_RCX, src_2.offset);
	emit_imul_r64(&curr, &size, REG_RAX, operand);
	if (dest.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, REG_RAX);
	else
		emit_store_local(&curr, &size, REG_RAX, dest.offset);
	return (size);
}

size_t	encode_div(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t	*curr = buf;
	size_t	size = 0;
	Location	dest = get_location(ctx, inst->dest);
	Location	src_1 = get_location(ctx,inst->src_1);
	Location	src_2 = get_location(ctx, inst->src_2);

	if (src_1.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, REG_RAX, src_1.reg);
	else
		emit_load_param(&curr, &size, REG_RAX, src_1.offset);
	emit_u8(&curr, &size, REX_W);
	emit_u8(&curr, &size, OP_CQO);

	X86Reg divisor = REG_RCX;
	if (src_2.type == LOC_REG)
		divisor = src_2.reg;
	else
		emit_load_param(&curr, &size, REG_RCX, src_2.offset);

	emit_u8(&curr, &size, REX_W);
	emit_u8(&curr, &size, OP_IDIV);
	emit_u8(&curr, &size, MOD_REG | (EXT_IDIV << 3) | divisor);

	if (dest.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, REG_RAX);
	else
		emit_store_local(&curr, &size, REG_RAX, dest.offset);
	return (size);
}

size_t encode_neg(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t	*curr = buf;
	size_t	size = 0;
	Location dest = get_location(ctx, inst->dest);
	Location src = get_location(ctx, inst->src_1);

	if (src.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, REG_RAX, src.reg);
	else
		emit_load_param(&curr, &size, REG_RAX, src.offset);
	emit_u8(&curr, &size, REX_W);
	emit_u8(&curr, &size, OP_IDIV);
	emit_u8(&curr, &size, MOD_REG | (EXT_NEG << 3) | REG_RAX);
	if (dest.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, REG_RAX);
	else
		emit_store_local(&curr, &size, REG_RAX, dest.offset);
	return (size);
}

size_t encode_not(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t	*curr = buf;
	size_t	size = 0;
	Location dest = get_location(ctx, inst->dest);
	Location src = get_location(ctx, inst->src_1);

	if (src.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, REG_RAX, src.reg);
	else
		emit_load_param(&curr, &size, REG_RAX, src.offset);
	emit_u8(&curr, &size, REX_W);
	emit_u8(&curr, &size, ALU_IMM8);
	emit_u8(&curr, &size, MOD_REG | (EXT_CMP << 3) | REG_RAX);
	emit_u8(&curr, &size, 0x00);
	emit_setcc(&curr, &size, CC_E, REG_RAX);
	emit_movzx(&curr, &size, REG_RAX, REG_RAX);
	if (src.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, REG_RAX);
	else
		emit_store_local(&curr, &size, REG_RAX, dest.offset);
	return (size);
}

size_t encode_arg(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)buf;
	(void)cnt;
	PendingCall *pc = &ctx->pending_call;

	pc->arg_vregs[pc->count++] = inst->src_1;
	return (0);
}

size_t encode_call(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t			*curr = buf;
	size_t			size = 0;
	Location		dest = get_location(ctx, inst->dest);
	PendingCall 	*pc = &ctx->pending_call;
	CallSiteList	*cs = &ctx->call_sites;

	// 1. Calculate stack arguments
	size_t	stack_args = (pc->count > 6) ? (pc->count - 6) : 0;
	size_t	reg_args = (pc->count > 6) ? 6 : pc->count;

	// 2. Apply alignment first before pushing
	bool 	needs_alignment = (stack_args % 2) != 0;
	if (needs_alignment)
	{
		emit_u8(&curr, &size, REX_W);
		emit_u8(&curr, &size, ALU_IMM);
		emit_u8(&curr, &size, MOD_REG | (EXT_SUB << 3) | REG_RSP);
		emit_u32(&curr, &size, 8);
	}

	// 3. Push stack arguments in reverse order
	for (size_t i = pc->count; i > 6; --i)
	{
		size_t	idx = i - 1;
		Location loc = get_location(ctx, pc->arg_vregs[idx]);
		if (loc.type == LOC_REG)
			emit_mov_reg_reg(&curr, &size, REG_RAX, loc.reg);
		else
			emit_load_param(&curr, &size, REG_RAX, loc.offset);
		emit_u8(&curr, &size, OP_PUSH + REG_RAX);
	}

	// 4. Handle register args
	//    a. Push params to stack
	for (int i = (int)reg_args; i > 0; --i)
	{
		int idx = i - 1;
		Location loc = get_location(ctx, pc->arg_vregs[idx]);
		if (loc.type == LOC_REG)
			emit_u8(&curr, &size, OP_PUSH + loc.reg);
		else
		{
			emit_load_param(&curr, &size, REG_RAX, loc.offset);
			emit_u8(&curr, &size, OP_PUSH + REG_RAX);
		}
	}

	//    b. Pop into abi registers
	for (size_t i = 0; i < reg_args; ++i)
		emit_u8(&curr, &size, OP_POP + arg_registers[i]);
	// 5. Emit call
	emit_u8(&curr, &size, REX_W);
	emit_u8(&curr, &size, MOV_IMM_R + REG_RAX);
	if (cs && buf)
	{
		CallSite site = {
			.patch_location = curr,
			.target_name = inst->func_name
		};
		if (cs->count < cs->capacity)
			cs->sites[cs->count++] = site;
	}
	emit_u64(&curr, &size, 0xDEADBEEFDEADBEEF); // Placeholder
	emit_u8(&curr, &size, OP_CALL_IND);
	emit_u8(&curr, &size, MOD_REG | (EXT_CALL << 3) | REG_RAX);

	// 6. Cleanup stack (arguments + padding)
	if (stack_args > 0 || needs_alignment)
	{
		size_t cleanup = stack_args * 8 + (needs_alignment ? 8 : 0);
		emit_u8(&curr, &size, REX_W);
		emit_u8(&curr, &size, ALU_IMM);
		emit_u8(&curr, &size, MOD_REG | (EXT_ADD << 3) | REG_RSP);
		emit_u32(&curr, &size, cleanup);
	}
	if (dest.type == LOC_REG)
		emit_mov_reg_reg(&curr, &size, dest.reg, REG_RAX);
	else
		emit_store_local(&curr, &size, REG_RAX, dest.offset);
	pc->count = 0;
	return (size);
}

size_t encode_ret(uint8_t *buf, size_t *cnt, IRInstruction *inst, JITContext *ctx)
{
	(void)cnt;
	uint8_t	*curr = buf;
	size_t	size = 0;
	Location src = get_location(ctx, inst->src_1);

	if (src.type == LOC_REG)
	{
		if (src.reg != REG_RAX)
			emit_mov_reg_reg(&curr, &size, REG_RAX, src.reg);
	}
	else
		emit_load_param(&curr, &size, REG_RAX, src.offset);
	// emit_u8(&curr, &size, REX_W);
	// emit_u8(&curr, &size, MOV_RM_R);
	// emit_u8(&curr, &size, MOD_REG | (REG_RBP << 3) | REG_RSP);
	emit_mov_reg_reg(&curr, &size, REG_RSP, REG_RBP);
	emit_u8(&curr, &size, OP_POP + REG_RBP);
	emit_u8(&curr, &size, OP_RET);
	return (size);
}



==================================================
FILE: ./srcs/jit/jit.c
==================================================
#include "jit.h"
#include "compile.h"
#include "defines.h"
#include "jit_internal.h"
#include "ir.h"
#include "layout.h"
#include <assert.h>
#include <stdbool.h>
#include <stddef.h>
#include <unistd.h>

// Calling convention
const X86Reg arg_registers[6] = {
	REG_RDI, REG_RSI, REG_RDX, REG_RCX, REG_R8, REG_R9,
};

/* ===================== */
/* LINEAR SCAN ALLOCATOR */
/* ===================== */

static bool is_allocatable_register(int reg)
{
	// 1. Reserved for Stack Management
	if (reg == REG_RSP || reg == REG_RBP)
	    return (false);

    // 2. Reserved for Instruction Constraints & Scratch
    // RAX: Return value, implicit in DIV/MUL
    // RDX: Implicit in DIV/MUL (high bits), scratch in encoders
    // RCX: Implicit in Shifts, scratch in encoders
    if (reg == REG_RAX || reg == REG_RDX || reg == REG_RCX)
        return (false);

    // 3. Reserved for ABI Compliance (Callee-Saved)
    // The JIT prologue does not save these, so we cannot touch them.
    // (RBX, R12, R13, R14, R15)
    if (reg == REG_RBX || (reg >= 12 && reg <= 15))
        return (false);

    return (true);
}

Location get_location(JITContext *ctx, size_t vreg)
{
	if (ctx->vreg_map[vreg].type != 0)
		return (ctx->vreg_map[vreg]);

	for (int i = 0; i < 16; ++i)
	{
		if (!is_allocatable_register(i))
			continue;
		if (!ctx->phys_regs[i])
		{
			ctx->phys_regs[i] = true;
			ctx->vreg_map[vreg].type = LOC_REG;
			ctx->vreg_map[vreg].reg = (X86Reg)i;
			return (ctx->vreg_map[vreg]);
		}
	}

	// If no space on registers, allocate to stack
	ctx->vreg_map[vreg].type = LOC_STACK;
	ctx->vreg_map[vreg].offset = -((int32_t)(vreg + 1) * 8);
	return (ctx->vreg_map[vreg]);
}

/* ============== */
/* DISPATCH TABLE */
/* ============== */

typedef size_t (*InstructionEncoder)(uint8_t*, size_t*, IRInstruction*, JITContext*);

static const InstructionEncoder encoders[] =
{
	#define X_OP(opcode, name, fmt, encoder) encoder,
	#include "ir_ops.def"
	#undef X_OP
};

static size_t	encode_inst(uint8_t *buf, IRInstruction *inst, JITContext *ctx)
{
	return (encoders[inst->opcode](buf, NULL, inst, ctx));
}

/* ============== */
/* MAIN JIT LOGIC */
/* ============== */

static size_t encode_prologue(uint8_t *buf, size_t stack_size, size_t param_count, JITContext *ctx)
{
	uint8_t	*curr = buf;
	size_t	size = 0;

	// 1. Standard prologue (Push RBP, move RBP, sub RSP)
	emit_u8(&curr, &size, OP_PUSH + REG_RBP);
	emit_u8(&curr, &size, REX_W);
	emit_u8(&curr, &size, MOV_RM_R);
	emit_u8(&curr, &size, MOD_REG | (REG_RSP << 3) | REG_RBP);
	if (stack_size > 0)
	{
		emit_u8(&curr, &size, REX_W);
        emit_u8(&curr, &size, ALU_IMM);
		emit_u8(&curr, &size, MOD_REG | (EXT_SUB << 3) | REG_RSP);
        emit_u32(&curr, &size, (uint32_t)stack_size);
	}

	// 2. Handle arguments
	for (size_t i = 0; i < param_count; ++i)
	{
		Location loc = get_location(ctx, i);
		if (i < 6)
		{
			X86Reg src_reg = arg_registers[i];
			if (loc.type == LOC_REG)
			{
				if (loc.reg != src_reg)
					emit_mov_reg_reg(&curr, &size, loc.reg, src_reg);
			}
			else
				emit_store_local(&curr, &size, src_reg, loc.offset);
		}
		else
		{
			int32_t src_offset = 16 + (i - 6) * 8;
			if (loc.type == LOC_REG)
				emit_load_param(&curr, &size, loc.reg, src_offset);
			else
			{
				emit_load_param(&curr, &size, REG_RAX, src_offset);
				emit_store_local(&curr, &size, REG_RAX, loc.offset);
			}
		}
    }

	return (size);
}

void jit_ctx_init(JITContext *ctx, Arena *data_arena, Arena *exec_arena)
{
	ctx->data_arena = data_arena;
	ctx->exec_arena = exec_arena;
	ctx->registry.capacity = MAX_FUNCTION_COUNT;
	ctx->registry.count = 0;
	ctx->registry.functions = arena_alloc(data_arena, sizeof(CompiledFunction) * ctx->registry.capacity);

	ctx->vreg_map = arena_alloc(data_arena, sizeof(Location) * MAX_VREGS_PER_FUNCTION);

	ctx->call_sites.capacity = MAX_CALL_SITES;
	ctx->call_sites.count = 0;
	ctx->call_sites.sites = arena_alloc(data_arena, sizeof(CallSite) * ctx->call_sites.capacity);
	memset(&ctx->pending_call, 0, sizeof(PendingCall));
}


static inline void reset_state(JITContext *ctx)
{
	ctx->pending_call.count = 0;
	ctx->patches = NULL;
	memset(ctx->label_offset, 0, sizeof(ctx->label_offset));
	memset(ctx->label_defined, 0, sizeof(ctx->label_defined));
	memset(ctx->vreg_map, 0, sizeof(Location) * MAX_VREGS_PER_FUNCTION);
	memset(ctx->phys_regs, 0, sizeof(ctx->phys_regs));
}

JITResult jit_compile_function(JITContext *ctx, IRFunction *ir_func, ASTNode *func)
{
	StringView func_name = func->function.name;
	size_t param_count = func->function.param_count;

	JITResult result = {0};
	reset_state(ctx);

	if (ir_func->label_count >= MAX_LABELS)
	{
		fprintf(stderr, BOLD_RED "  > too many labels in function '%.*s' (max %d)\n" RESET,
				(int)func_name.len, func_name.start, MAX_LABELS);
		return (result);
	}

    size_t stack_bytes = (ir_func->vreg_count * 8 + 15) & ~15;

	// == PASS 1: Calculate size ===
    size_t predicted_size = encode_prologue(NULL, stack_bytes, param_count, ctx);
    IRChunk *chunk = ir_func->head;
	size_t instruction_count = 0;
    while (chunk)
	{
        for (size_t i = 0; i < chunk->count; ++i)
		{
            predicted_size += encode_inst(NULL, &chunk->instructions[i], ctx);
			instruction_count++;
		}
        chunk = chunk->next;
    }

	assert(instruction_count == ir_func->total_count && "IR instruction count mismatch");
	
	// === Allocate ===
	result.code = arena_alloc_aligned(ctx->exec_arena, predicted_size, 16);
    if (!result.code)
	{
		fprintf(stderr, BOLD_RED "  > failed to allocate %zu bytes for JIT code\n" RESET,
				predicted_size);
	}

	// === PASS 2: Emit ===
	reset_state(ctx);
	uint8_t *write_ptr = result.code;
	size_t prologue_size = encode_prologue(write_ptr, stack_bytes, param_count, ctx);
	write_ptr += prologue_size;
    
    chunk = ir_func->head;
    while (chunk)
	{
        for (size_t i = 0; i < chunk->count; ++i)
		{
			size_t inst_size = encode_inst(write_ptr, &chunk->instructions[i], ctx);
            write_ptr += inst_size;
			size_t written = write_ptr - result.code;
			if (written > predicted_size)
			{
				fprintf(stderr, BOLD_RED
						"  > JIT CODE GENERATION BUG: buffer overrun!\n"
						"  	 Predicted: %zu bytes\n"
						"    Actually wrote: %zu bytes\n"
						"    Instruction: %s\n" RESET,
						predicted_size, written,
						ir_opcode_name(chunk->instructions[i].opcode));
				abort();
			}
		}
        chunk = chunk->next;	
    }

	// === Verify size match ===
	size_t actual_size = write_ptr - result.code;
	if (actual_size != predicted_size)
	{
		fprintf(stderr, BOLD_RED
				"  > JIT CODE GENERATION BUG: size mismatch!\n"
				"    Pass 1 predicted: %zu bytes\n"
				"    Pass 2 generated: %zu bytes\n"
				"    Difference: %zd bytes\n" RESET,
				predicted_size, actual_size,
				(ssize_t)actual_size - (ssize_t)predicted_size);
		fprintf(stderr,"\n  > IR dump for failed function:\n");
		ir_print(ir_func);
		abort();
	}

	result.size = actual_size;

	// === Register this function ===
    if (ctx->registry.count >= MAX_FUNCTION_COUNT)
	{
		fprintf(stderr, BOLD_RED
				"  > too many functions (max %d)\n" RESET,
				MAX_FUNCTION_COUNT);
		return ((JITResult){0});
	}
	ctx->registry.functions[ctx->registry.count++] = (CompiledFunction){
			.name = func_name,
			.code_addr = result.code,
			.code_size = result.size
    };
	return (result);
}

bool jit_link_all(JITContext *ctx, ErrorContext *errors)
{
	bool	success = true;

	for (size_t i = 0; i < ctx->call_sites.count; ++i)
	{
		CallSite *site = &ctx->call_sites.sites[i];

		uint8_t *target_addr = NULL;
		for (size_t j = 0; j < ctx->registry.count; ++j)
		{
			if (sv_eq(site->target_name, ctx->registry.functions[j].name))
			{
				target_addr = ctx->registry.functions[j].code_addr;
				break;
			}
		}

		if (!target_addr)
		{
			error_add(errors, ERROR_CODEGEN, ERROR_LEVEL_ERROR, NULL, 0, 0,
					"undefined reference to function '%.*s'",
					(int)site->target_name.len, site->target_name.start);
			success = false;
			continue;
		}
		
		uint64_t addr = (uint64_t)target_addr;
		memcpy(site->patch_location, &addr, 8);
	}
	return (success);
}

bool	jit_compile_pass(JITContext *jit_ctx, CompilationContext *comp_ctx, 
					ErrorContext *errors)
{
	for (size_t i = 0; i < comp_ctx->count; ++i)
	{
		CompilationUnit *unit = &comp_ctx->units[i];
		if (!unit->parsed_ok)
			continue;

		for (size_t j = 0; j < unit->ast->translation_unit.count; ++j)
		{
			ASTNode *func = unit->ast->translation_unit.declarations[j];
			if (func->function.is_prototype)
                continue;
			printf("  :: compiling symbol '%.*s'\n", (int)func->function.name.len, func->function.name.start);

			IRFunction *ir = ir_gen(jit_ctx->data_arena, func);
			if (!ir)
			{
				fprintf(stderr,  BOLD_RED "  > ir generation failed\n" RESET);
				error_fatal(errors, unit->file.name, func->line, 0,
						"IR Generation failed for function '%.*s'",
						(int)func->function.name.len, func->function.name.start);
				return (false);
			}

			if (sv_eq_cstr(func->function.name, "main"))
				ir_print(ir);

			JITResult jit = jit_compile_function(jit_ctx, ir, func);
			if (!jit.code)
			{
				fprintf(stderr, BOLD_RED "  > compilation failed\n" RESET);
				error_fatal(errors, unit->file.name, func->line, 0,
						"JIT compilation failed for function '%.*s'",
						(int)func->function.name.len, func->function.name.start);
				return (false);
			}
		}
	}
	return (true);
}


==================================================
FILE: ./srcs/lexer/helpers.c
==================================================
/**
 * @file
 * @brief Helper functions for lexer
 */

#include "lexer.h"

static inline bool is_comment(Lexer *l);

void lexer_init(Lexer *l, FileMap *file)
{
	l->file = file;
	l->start = file->data;
	l->curr = file->data;
	l->end = file->data + file->length;
	l->line = 1;
	l->column = 1;
}

/**
 * @brief Looks at the next char in the file we are tokenizing without advancing
 *
 * @param l 
 * @return next character	
 */
char lexer_peek(Lexer *l)
{
	if (l->curr >= l->end)
		return ('\0');
	return (*l->curr);
}

/**
 * @brief Looks at the char + 2 in the file we are tokenizing without advancing
 *
 * @param l 
 */
char lexer_peek_next(Lexer *l)
{
	if (l->curr + 1 >= l->end)
		return ('\0');
	return (*(l->curr + 1));
}

char lexer_advance(Lexer *l)
{
	l->curr++;
	l->column++;
	return l->curr[-1];
}

/**
 * @brief Skips whitespaces and comments
 *
 * @param l 
 */
void lexer_skip_whitespace(Lexer *l)
{
	while (l->curr < l->end)
	{
		char c = *l->curr;
		switch (c)
		{
			case ' ':
			case '\r':
			case '\t':
				lexer_advance(l);
				break;
			case '\n':
				l->line++;
				l->column = 1;
				lexer_advance(l);
				break;
			case '/':
				if (is_comment(l))
					break;
				else				// is division
					return;
			case '#':
				while (lexer_peek(l) != '\n' && l->curr < l->end)
					lexer_advance(l);
				break;
			default:
				return;
		}
	}
}

static inline bool is_comment(Lexer *l)
{
	bool result = false;
	if (lexer_peek_next(l) == '/')
	{
		result = true;
		while (lexer_peek(l) != '\n' && l->curr < l->end)
			lexer_advance(l);
	}
	else if (lexer_peek_next(l) == '*')
	{
		result = true;
		lexer_advance(l);
		lexer_advance(l);
		while (l->curr < l->end)
		{
			if (lexer_peek(l) == '*' && lexer_peek_next(l) == '/')
			{
				lexer_advance(l);
				lexer_advance(l);
				break;
			}
			if (lexer_peek(l) == '\n')
			{
				l->line++;
				l->column = 1;
			}
			lexer_advance(l);
		}
	}
	return (result);
}

/**
 * @brief Makes a token containing a text field
 *
 * @param l 
 * @param type 
 * @param text 
 * @return new token for parser
 */
Token	lexer_make_token(Lexer *l, TokenType type, StringView text)
{
	Token result = {
		.type = type,
		.text = text,
		.line = l->line,
		.column = l->column 
	};
	return (result);
}

/**
 * @brief Makes a token without a text field
 *
 * @param l 
 * @param type 
 * @return new token for parser
 */
Token	lexer_make_token_no_sv(Lexer *l, TokenType type)
{
	Token result = {
		.type = type,
		.line = l->line,
		.column = l->column 
	};
	return (result);
}


==================================================
FILE: ./srcs/lexer/lexer.c
==================================================
#include "lexer.h"

static TokenType check_keyword(StringView text);

/**
 * @brief Lexer works on a as-requested basis,
 * returns the next token for the parser
 *
 * @param l 
 * @return Token
 */
Token lexer_next(Lexer *l)
{
	lexer_skip_whitespace(l);

	if (l->curr >= l->end)
		return (lexer_make_token_no_sv(l, TOKEN_EOF));

	char c = *l->curr;
	if (isdigit(c))
	{
		const char *start = l->curr;
		while (l->curr < l->end && isdigit(*l->curr))
			lexer_advance(l);
		StringView text = { .start = start, .len = l->curr - start };
		return (lexer_make_token(l, TOKEN_NUMBER, text));
	}

	if (isalpha(c) || c == '_')
	{
		const char *start = l->curr;
		while (l->curr < l->end && (isalnum(*l->curr) || *l->curr == '_'))
			lexer_advance(l);

		StringView	text = {.start = start, .len = l->curr - start};
		TokenType	type = check_keyword(text);

		return (lexer_make_token(l, type, text));
	}

	lexer_advance(l);
	StringView text = { .start = l->curr - 1, .len = 1 };

	switch (c)
	{
		case '+': return (lexer_make_token(l, TOKEN_PLUS, text));
        case '-': return (lexer_make_token(l, TOKEN_MINUS, text));
        case '*': return (lexer_make_token(l, TOKEN_STAR, text));
        case '/': return (lexer_make_token(l, TOKEN_SLASH, text));
        case '(': return (lexer_make_token(l, TOKEN_LPAREN, text));
        case ')': return (lexer_make_token(l, TOKEN_RPAREN, text));
        case '{': return (lexer_make_token(l, TOKEN_LBRACE, text));
        case '}': return (lexer_make_token(l, TOKEN_RBRACE, text));
        case ';': return (lexer_make_token(l, TOKEN_SEMICOLON, text));
		case ',': return (lexer_make_token(l, TOKEN_COMMA, text));
		case '!':
			if (lexer_peek(l) == '=')
			{
				lexer_advance(l);
				return (lexer_make_token_no_sv(l, TOKEN_BANG_EQUAL));
			}
			return (lexer_make_token_no_sv(l, TOKEN_BANG));
		case '=':
			if (lexer_peek(l) == '=')
			{
				lexer_advance(l);
				return (lexer_make_token_no_sv(l, TOKEN_EQUAL_EQUAL));
			}
			return (lexer_make_token_no_sv(l, TOKEN_EQUAL));
		case '>':
			if (lexer_peek(l) == '=')
			{
				lexer_advance(l);
				return (lexer_make_token_no_sv(l, TOKEN_GREATER_EQUAL));
			}
			return (lexer_make_token_no_sv(l, TOKEN_GREATER));
		case '<':
			if (lexer_peek(l) == '=')
			{
				lexer_advance(l); 
				return (lexer_make_token_no_sv(l, TOKEN_LESS_EQUAL));
			}
			return (lexer_make_token_no_sv(l, TOKEN_LESS));
		default:  return (lexer_make_token_no_sv(l, TOKEN_ERROR));
	}
}

static TokenType check_keyword(StringView text)
{
	#define X_TOKEN(name, str, is_keyword, prec, prefix_fn, infix_fn, stmt_fn) \
		if (is_keyword && sv_eq_cstr(text, str)) return (name);
	#include "lexer_tokens.def"
	#undef X_TOKEN
	return (TOKEN_IDENTIFIER);
}


==================================================
FILE: ./srcs/main.c
==================================================
#include <stddef.h>
#define MEMARENA_IMPLEMENTATION
#include "memarena.h"
#include "jit.h"
#include "compile.h"
#include "layout.h"
#include "utils.h"
#include "error_handler.h"
#include "cleanup.h"
#include <string.h>
#include <stdio.h>
#include <sys/mman.h>

int main(int argc, char **argv)
{
	int	exit_code = 1;

	Arena ast_arena = arena_init(PROT_READ | PROT_WRITE);
	Arena jit_data_arena = arena_init(PROT_READ | PROT_WRITE);
	Arena jit_exec_arena = arena_init(PROT_READ | PROT_WRITE);

	ErrorContext	errors;
	error_context_init(&errors, &ast_arena);
	ResourceTracker	resources;
	resource_tracker_init(&resources, argc, &ast_arena);

	print_header();
	
	print_phase(1, "INITIALIZATION");
	CompilationContext ctx;
	if (!compile_ctx_init(&ctx, &ast_arena, &errors, argc - 1))
	{
		fprintf(stderr, BOLD_RED "\n  > initialization failed\n" RESET);
		goto cleanup;
	}

	for (int i = 1; i < argc; ++i)
	{
		if (!compile_ctx_add_file(&ctx, argv[i], &resources))
		{
			fprintf(stderr, BOLD_RED "\n  > initialization failed\n" RESET);
			goto cleanup;
		}
	}

	print_phase(2, "PARSING");
	if (!compile_parse_all(&ctx))
	{
		fprintf(stderr, BOLD_RED "\n  > parsing failed\n" RESET);
		goto cleanup;
	}

	print_phase(3, "SEMANTICS");
	if (!compile_analyze_all(&ctx))
	{
		fprintf(stderr, BOLD_RED "\n  > semantic analysis failed\n" RESET);
		goto cleanup;
	}

	print_phase(4, "JIT");
	JITContext jit_ctx;
	jit_ctx_init(&jit_ctx, &jit_data_arena, &jit_exec_arena);
	if (!jit_compile_pass(&jit_ctx, &ctx, &errors))
		goto cleanup;

	if (!jit_link_all(&jit_ctx, &errors))
	{
		fprintf(stderr, BOLD_RED "  > linking failed\n" RESET);
		goto cleanup;
	}

	if (!arena_set_prot(&jit_exec_arena, PROT_READ | PROT_EXEC))
	{
		perror(BOLD_RED "  > failed to set executable permissions" RESET);
		goto cleanup;
	}

	print_phase(5, "EXECUTION");
	
	bool found_main = false;
	for (size_t i = 0; i < jit_ctx.registry.count; i++)
	{
    	if (sv_eq_cstr(jit_ctx.registry.functions[i].name, "main"))
		{
        	JITFunc main_func = (JITFunc)jit_ctx.registry.functions[i].code_addr;
        	int64_t result = main_func();
			printf(GREEN "  -----------------------------------------\n");
    		printf("   RETURN CODE >> " BOLD_WHITE "%lld" RESET "\n", result);
    		printf(GREEN "  -----------------------------------------\n" RESET);
			found_main = true;
			exit_code = 0;
        	break;
    	}
	}

	if (!found_main)
	{
		error_fatal(&errors, NULL, 0, 0, "No 'main' function found.");
		goto cleanup;
	}

cleanup:
	if (error_has_errors(&errors) || error_has_fatal(&errors))
		error_print_all(&errors);
	resource_cleanup_all(&resources);
	arena_free(&ast_arena);
	arena_free(&jit_data_arena);
	arena_free(&jit_exec_arena);

	return (exit_code);
}


==================================================
FILE: ./srcs/parser/parser_expr.c
==================================================
#include "parser_internal.h"

ASTNode	*parse_expression(Parser *parser, Precedence precedence)
{
	if (parser->expr_depth >= MAX_EXPRESSION_DEPTH)
	{
		parser_error(parser, 
				"Expression too deeply nested (max %d)",
				MAX_EXPRESSION_DEPTH);
		return (NULL);
	}
	parser->expr_depth++;
	parser_advance(parser);
	ParsePrefixFn prefix = rules[parser->current.type].prefix;

	if (prefix == NULL)
	{
		parser_error(parser, "Expect expression");
		parser->expr_depth--;
		return (NULL);
	}

	ASTNode *left = prefix(parser);
	while (precedence < get_token_precedence(parser->next.type))
	{
		parser_advance(parser);
		ParseInfixFn infix = rules[parser->current.type].infix;
		if (infix)
			left = infix(parser, left);
	}
	parser->expr_depth--;
	return (left);
}

ASTNode	*parse_assignment(Parser *parser, ASTNode *left)
{
	if (left->type != AST_IDENTIFIER)
	{
		parser_error(parser, "Invalid assignment target");
		return (NULL);
	}
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	node->type = AST_ASSIGNMENT;
	node->assignment.var_name = left->identifier.name;
	node->assignment.value = parse_expression(parser, PREC_ASSIGNMENT);
	return (node);
}

ASTNode	*parse_unary(Parser *parser)
{
	TokenType operator_type = parser->current.type;
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));

	switch (operator_type)
	{
		case TOKEN_MINUS:	node->type = AST_NEGATE; break;
		case TOKEN_BANG:	node->type = AST_NOT; break;
		default:			node->type = AST_NUMBER; break;
	}

	node->unary.operand = parse_expression(parser, PREC_UNARY);
	return (node);
}

ASTNode	*parse_binary(Parser *parser, ASTNode *left)
{
	TokenType operator_type = parser->current.type;
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));

	switch (operator_type)
	{
		case TOKEN_PLUS:			node->type = AST_ADD; break;
		case TOKEN_MINUS:			node->type = AST_SUB; break;
		case TOKEN_STAR:			node->type = AST_MUL; break;
		case TOKEN_SLASH:			node->type = AST_DIV; break;
		case TOKEN_EQUAL_EQUAL:		node->type = AST_EQUAL; break;
		case TOKEN_BANG_EQUAL:		node->type = AST_NOT_EQUAL; break;
		case TOKEN_LESS:			node->type = AST_LESS; break;
		case TOKEN_LESS_EQUAL:		node->type = AST_LESS_EQUAL; break;
		case TOKEN_GREATER:			node->type = AST_GREATER; break;
		case TOKEN_GREATER_EQUAL:	node->type = AST_GREATER_EQUAL; break;
		default: break;
	}

	Precedence precedence = get_token_precedence(operator_type);
	node->binary.left = left;
	node->binary.right = parse_expression(parser, (Precedence)(precedence));
	return (node);
}

ASTNode	*parse_number(Parser *parser)
{
	ASTNode	*node = arena_alloc(parser->arena, sizeof(ASTNode));
	node->type = AST_NUMBER;
	node->number.value = parser->current.text;
	node->line = parser->current.line;
	return (node);
}

ASTNode	*parse_grouping(Parser *parser)
{
	ASTNode	*expression = parse_expression(parser, PREC_NONE);
	parser_consume(parser, TOKEN_RPAREN, "Expect ')' after expression.");
	return (expression);
}

ASTNode	*parse_identifier(Parser *parser)
{
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	node->type = AST_IDENTIFIER;
	node->identifier.name = parser->current.text;
	node->line = parser->current.line;
	return (node);
}

ASTNode	*parse_call(Parser *parser, ASTNode *callee)
{
	if (callee->type != AST_IDENTIFIER)
	{
		parser_error(parser, "Can only call functions");
		return (NULL);
	}

	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	node->type = AST_CALL;
	node->call.function_name = callee->identifier.name;
	node->line = callee->line;
	node->column = callee->column;

	ASTNode **args = arena_alloc(parser->arena, sizeof(ASTNode*) * MAX_PARAMS_PER_FUNCTION);
	size_t arg_count = 0;

	if (!check(parser, TOKEN_RPAREN))
	{
		do
		{
			if (arg_count >= MAX_PARAMS_PER_FUNCTION)
			{
				parser_error(parser, "Too many arguments (max %d)",
						MAX_PARAMS_PER_FUNCTION);
				parser_synchronize(parser);
				break;
			}
			ASTNode *arg = parse_expression(parser, PREC_ASSIGNMENT);
			if (!arg)
			{
				parser_synchronize(parser);
				break;
			}
			args[arg_count++] = arg;
		} while (match(parser, TOKEN_COMMA));
	}

	parser_consume(parser, TOKEN_RPAREN, "Expected ')' after arguments");
	node->call.args = args;
	node->call.arg_count = arg_count;

	return (node);
}


==================================================
FILE: ./srcs/parser/parser_stmt.c
==================================================
#include "parser_internal.h"

ASTNode	*parse_statement(Parser *parser)
{
	TokenType type = parser->next.type;
	ParseStmtFn stmt_fn = rules[type].stmt;
	if (stmt_fn)
		return (stmt_fn(parser));

	return (parse_expr_stmt(parser));
}

ASTNode* parse_block(Parser *parser)
{
    parser_consume(parser, TOKEN_LBRACE, "Expected '{'");
    
    ASTNode **stmts = arena_alloc(
			parser->arena, sizeof(ASTNode*) * MAX_BLOCK_STATEMENTS);
    size_t count = 0;
    
    while (!check(parser, TOKEN_RBRACE) 
			&& !check(parser, TOKEN_EOF))
	{
		if (count >= MAX_BLOCK_STATEMENTS)
		{
			parser_error(parser, 
					"Block too large (max %d statements)",
					MAX_BLOCK_STATEMENTS);
			parser_synchronize(parser);
			break;
		}
		ASTNode *stmt = parse_statement(parser);
		if (stmt)
			stmts[count++] = stmt;
		else
			parser_synchronize(parser);
    }
    
    parser_consume(parser, TOKEN_RBRACE, "Expected '}'");
    ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
    *node = (ASTNode){
        .type = AST_BLOCK,
        .block = {
            .statements = stmts,
            .count = count
        }
    };
    return (node);
}

ASTNode	*parse_function(Parser *parser)
{
	if (!match(parser, TOKEN_INT))
		return (NULL);

	parser_consume(parser, TOKEN_IDENTIFIER, "Expected function name.");
	StringView func_name = parser->current.text;

	parser_consume(parser, TOKEN_LPAREN, "Expected '(' after function name.");

	Parameter *params = NULL;
	size_t param_count = 0;

	if (!check(parser, TOKEN_RPAREN))
	{
		params = arena_alloc(parser->arena, sizeof(Parameter) * 16);
		if (check(parser, TOKEN_IDENTIFIER) && sv_eq_cstr(parser->next.text, "void"))
			parser_advance(parser);
		else
		{
			do
			{
				parser_consume(parser, TOKEN_INT, "Expected parameter type");
				parser_consume(parser, TOKEN_IDENTIFIER, "Expected parameter name");
				params[param_count++] = (Parameter){
					.name = parser->current.text,
					.type = TYPE_INT64
				};
			} while (match(parser, TOKEN_COMMA));
		}
	}

	parser_consume(parser, TOKEN_RPAREN, "Expected ')' after parameters.");

	ASTNode *body = NULL;
	bool is_prototype = false;
	if (match(parser, TOKEN_SEMICOLON))
		is_prototype = true;
	else
		body = parse_block(parser);

	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	*node = (ASTNode){
		.type = AST_FUNCTION,
		.function = {
			.name = func_name,
			.params = params,
			.param_count = param_count,
			.body = body,
			.is_prototype = is_prototype
		}
	};
	return (node);
}

ASTNode	*parse_var_decl(Parser *parser)
{
	parser_consume(parser, TOKEN_INT, "Expected 'int'");
	parser_consume(parser, TOKEN_IDENTIFIER, "Expected variable name");
	StringView var_name = parser->current.text;
	ASTNode *init = NULL;
	if (match(parser, TOKEN_EQUAL))
		init = parse_expression(parser, PREC_NONE);
	parser_consume(parser, TOKEN_SEMICOLON, "Expected ';'");
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	*node = (ASTNode){
		.type = AST_VAR_DECL,
		.var_decl = { .var_name = var_name, .initializer = init }
	};
	return (node);
}

ASTNode	*parse_return(Parser *parser)
{
	parser_consume(parser, TOKEN_RETURN, "Expected 'return'");
	ASTNode *expr = NULL;
	if (!check(parser, TOKEN_SEMICOLON))
		expr = parse_expression(parser, PREC_NONE);
	parser_consume(parser, TOKEN_SEMICOLON, "Expected ';'");
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	*node = (ASTNode){
		.type = AST_RETURN,
		.return_stmt = { .expression = expr }
	};
	return (node);
}

ASTNode	*parse_if(Parser *parser)
{
	parser_consume(parser, TOKEN_IF, "Expected 'if'");
	parser_consume(parser, TOKEN_LPAREN, "Expected '('");
	ASTNode *condition = parse_expression(parser, PREC_NONE);
	parser_consume(parser, TOKEN_RPAREN, "Expected ')'");
	ASTNode *then_branch = parse_statement(parser);
	ASTNode *else_branch = NULL;
	if (match(parser, TOKEN_ELSE))
		else_branch = parse_statement(parser);
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	*node = (ASTNode){
		.type = AST_IF,
		.if_stmt = { condition, then_branch, else_branch }
	};
	return (node);
}

ASTNode	*parse_while(Parser *parser)
{
	parser_consume(parser, TOKEN_WHILE, "Expected 'while'");
	parser_consume(parser, TOKEN_LPAREN, "Expected '('");
	ASTNode *condition = parse_expression(parser, PREC_NONE);
	parser_consume(parser, TOKEN_RPAREN, "Expected ')'");
	ASTNode *body = parse_statement(parser);
	ASTNode *node = arena_alloc(parser->arena, sizeof(ASTNode));
	*node = (ASTNode){
		.type = AST_WHILE,
		.while_stmt = { condition, body }
	};
	return (node);
}

ASTNode	*parse_expr_stmt(Parser *parser)
{
	ASTNode *expr = parse_expression(parser, PREC_NONE);
	parser_consume(parser, TOKEN_SEMICOLON, "Expected ';'");
	return (expr);
}


==================================================
FILE: ./srcs/parser/parser_utils.c
==================================================
#include "parser_internal.h"

void	parser_advance(Parser *parser)
{
	parser->current = parser->next;
	while (true)
	{
		parser->next = lexer_next(parser->lexer);
		if (parser->next.type != TOKEN_ERROR)
			break;
	}
}

void	parser_consume(Parser *parser, TokenType type, const char *message)
{
	if (parser->next.type == type)
	{
		parser_advance(parser);
		parser->panic_mode = false;
		return;
	}
	parser_error(parser, "%s (got %s)", message, 
			token_type_name(parser->next.type));
	parser_synchronize(parser);
}

void parser_error(Parser *parser, const char *fmt, ...)
{
	if (parser->panic_mode)
		return;
	parser->panic_mode = true;
	va_list	args;
	va_start(args, fmt);
	char	buffer[512];
	vsnprintf(buffer, sizeof(buffer), fmt, args);
	va_end(args);

	error_parser(parser->errors, parser->lexer->file->name,
			parser->current.line, parser->current.column,
			"%s", buffer);
}

void	parser_synchronize(Parser *parser)
{
	parser->panic_mode = false;
	while (parser->next.type != TOKEN_EOF)
	{
		if (parser->current.type == TOKEN_SEMICOLON)
			return;
		switch (parser->next.type)
		{
			case TOKEN_IF:
			case TOKEN_WHILE:
			case TOKEN_RETURN:
			case TOKEN_INT:
			case TOKEN_LBRACE:
				return;
			default:
				break;
		}
		parser_advance(parser);
	}
}
bool match(Parser *parser, TokenType type)
{
	if (parser->next.type == type)
	{
		parser_advance(parser);
		return (true);
	}
	return (false);
}

bool check(Parser *parser, TokenType type)
{
	return (parser->next.type == type);
}



==================================================
FILE: ./srcs/parser/parser.c
==================================================
#include "parser_internal.h"
#include "ast.h"
#include "defines.h"
#include "error_handler.h"
#include "lexer.h"

const ParseRule rules[] = {
	#define X_TOKEN(name, str, is_keyword, prec, prefix, infix, stmt) {str, prec, prefix, infix, stmt},
	#include "lexer_tokens.def"
	#undef X_TOKEN
};

ASTNode	*parser_parse(Lexer *lexer, Arena *arena, ErrorContext *errors)
{
	Parser parser = {0};
	parser.lexer = lexer;
	parser.arena = arena;
	parser.errors = errors;
	parser_advance(&parser);

	ASTNode **declarations = arena_alloc(
			arena, sizeof(ASTNode*) * MAX_FUNCTION_COUNT);
	size_t count = 0;

	while (!check(&parser, TOKEN_EOF))
	{
		if (count >= MAX_FUNCTION_COUNT)
		{
			parser_error(&parser, "Too many global declarations (max %d)",
					MAX_FUNCTION_COUNT);
			return (NULL);
		}
		if (check(&parser, TOKEN_INT))
			declarations[count++] = parse_function(&parser);
		else
		{
			parser_error(&parser, "Expected function declaration.");
			return (NULL);
		}
	}

	ASTNode *node = arena_alloc(arena, sizeof(ASTNode));
	*node = (ASTNode){
		.type = AST_TRANSLATION_UNIT,
		.translation_unit = {
			.declarations = declarations,
			.count = count
		}
	};

	return (node);
}

const char	*token_type_name(TokenType type)
{
	size_t rule_count = sizeof(rules) / sizeof(rules[0]);
	if (type < 0 || (size_t)type >= rule_count)
		return ("UNKNOWN");
	return (rules[type].name);
}

Precedence	get_token_precedence(TokenType type)
{
	size_t rule_count = sizeof(rules) / sizeof(rules[0]);
	if (type < 0 || (size_t)type >= rule_count)
		return (PREC_NONE);
	return (rules[type].prec);
}


==================================================
FILE: ./srcs/semantic/semantic.c
==================================================
#include "semantic.h"
#include "compile.h"
#include "defines.h"
#include <stdbool.h>
#include <stdio.h>

Scope *semantic_scope_enter(SemanticAnalyzer *sa)
{
	Scope *new_scope = arena_alloc(sa->arena, sizeof(Scope));
	new_scope->parent = sa->current;
	new_scope->var_count = 0;
	sa->current = new_scope;
	return (new_scope);
}

void semantic_scope_exit(SemanticAnalyzer *sa)
{
	if (sa->current)
		sa->current = sa->current->parent;
}

VarInfo *semantic_scope_lookup(Scope *scope, StringView name)
{
	while (scope)
	{
		for (size_t i = 0; i < scope->var_count; ++i)
		{
			if (sv_eq(scope->vars[i].name, name))
				return (&scope->vars[i]);
		}
		scope = scope->parent;
	}
	return (NULL);
}

bool semantic_scope_declare(SemanticAnalyzer *sa, StringView name, 
							DataType type, int line)
{
	Scope *scope = sa->current;
	if (!scope)
		return (false);

	for (size_t i = 0; i < scope->var_count; ++i)
	{
		if (sv_eq(scope->vars[i].name, name))
		{
			error_semantic(sa->errors, sa->filename, line, 0,
					"redeclaration of variable '%.*s' (first declared at line %d)",
					(int)name.len, name.start, scope->vars[i].line);
			return (false);
		}
	}

	if (scope->var_count >= MAX_VARS_PER_SCOPE)
	{
		error_semantic(sa->errors, sa->filename, line, 0,
				"too many variables in scope (max %d)", MAX_VARS_PER_SCOPE);
		return (false);
	}

	scope->vars[scope->var_count] = (VarInfo){
		.name = name,
		.type = type,
		.initialized = false,
		.line = line
	};
	scope->var_count++;
	return (true);
}

static bool analyze_expression(SemanticAnalyzer *sa, ASTNode *node)
{
	if (!node)
		return (true);
	switch (node->type)
	{
		case AST_NUMBER:
			return (true);
		case AST_IDENTIFIER:
		{
			VarInfo *var = semantic_scope_lookup(sa->current, node->identifier.name);
			if (!var)
			{
				error_semantic(sa->errors, sa->filename, node->line, node->column,
						"use of undeclared identifier '%.*s'",
						(int)node->identifier.name.len, node->identifier.name.start);
				return (false);
			}
			return (true);
		}
		case AST_CALL:
		{
			bool is_visible = false;
			for (size_t i = 0; i < sa->visible_count; ++i)
			{
				if (sv_eq(sa->visible_funcs[i], node->call.function_name))
				{
					is_visible = true;
					break;
				}
			}

			if (!is_visible)
			{
				error_semantic(sa->errors, sa->filename, node->line, node->column,
						"implicit declaration of function '%.*s' is invalid in tinyCompile",
						(int)node->call.function_name.len, node->call.function_name.start);
				return (false);
			}

			FunctionInfo *func = semantic_global_lookup_function(
					sa->global, node->call.function_name);
			if (!func)
			{
				error_semantic(sa->errors, sa->filename, node->line, node->column,
						"call to undefined function '%.*s'", 
						(int)node->call.function_name.len, node->call.function_name.start);
				return (false);
			}

			if (node->call.arg_count != func->param_count)
			{
				error_semantic(sa->errors, sa->filename, node->line, node->column,
						"function '%.*s' expects %zu arguments, got %zu",
						(int)node->call.function_name.len, node->call.function_name.start,
						func->param_count, node->call.arg_count);
				return (false);
			}

			bool all_ok = true;
			for (size_t i = 0; i < node->call.arg_count; ++i)
			{
				if (!analyze_expression(sa, node->call.args[i]))
					all_ok = false;
			}
			return (all_ok);
		}
		case AST_ADD:
		case AST_SUB:
		case AST_MUL:
		case AST_DIV:
		{
			bool left_ok = analyze_expression(sa, node->binary.left);
			bool right_ok = analyze_expression(sa, node->binary.right);
			return (left_ok && right_ok);
		}
		case AST_NEGATE:
		case AST_NOT:
			return (analyze_expression(sa, node->unary.operand));
		default:
			return (true);
	}
}

static bool analyze_statement(SemanticAnalyzer *sa, ASTNode *node)
{
	if (!node)
		return (true);

	switch (node->type)
	{
		case AST_VAR_DECL:
		{
			bool init_ok = true;
			if (node->var_decl.initializer)
				init_ok = analyze_expression(sa, node->var_decl.initializer);
			bool decl_ok = semantic_scope_declare(sa, node->var_decl.var_name,
					TYPE_INT64, node->line);
			return (init_ok && decl_ok);
		}
		case AST_ASSIGNMENT:
		{
			VarInfo *var = semantic_scope_lookup(sa->current, node->assignment.var_name);
			if (!var)
			{
				error_semantic(sa->errors, sa->filename, node->line, node->column,
						"assignment to undeclared variable '%.*s'",
						(int)node->assignment.var_name.len,
						node->assignment.var_name.start);
				return (false);
			}
			return (analyze_expression(sa, node->assignment.value));
		}
		case AST_RETURN:
		{
			if (node->return_stmt.expression)
			{
				if (sa->current_return_type == TYPE_VOID)
				{
					error_semantic(sa->errors, sa->filename,
							node->line, node->column,
							"void function should not return a value");
					return (false);
				}
				return (analyze_expression(sa, node->return_stmt.expression));
			}
			else
			{
				if (sa->current_return_type != TYPE_VOID)
				{
					error_semantic(sa->errors, sa->filename,
							node->line, node->column,
							"non-void function must return a value");
					return (false);
				}
				return (true);
			}
		}
		case AST_IF:
		{
			bool cond_ok = analyze_expression(sa, node->if_stmt.condition);
			bool then_ok = analyze_statement(sa, node->if_stmt.then_branch);
			bool else_ok = true;
			if (node->if_stmt.else_branch)
				else_ok = analyze_statement(sa, node->if_stmt.else_branch);
			return (cond_ok && then_ok && else_ok);
		}
		case AST_WHILE:
		{
			bool cond_ok = analyze_expression(sa, node->while_stmt.condition);
			bool body_ok = analyze_statement(sa, node->while_stmt.body);
			return (cond_ok && body_ok);
		}
		case AST_BLOCK:
		{
			semantic_scope_enter(sa);
			bool all_ok = true;
			for (size_t i = 0; i < node->block.count; ++i)
			{
				if (!analyze_statement(sa, node->block.statements[i]))
					all_ok = false;
			}
			semantic_scope_exit(sa);
			return (all_ok);
		}
		default:
			return (analyze_expression(sa, node));
	}
}

bool	semantic_global_declare_function(GlobalScope *global, ErrorContext *errors, 
			ASTNode *func_node, const char *filename)
{
	if (!func_node || func_node->type != AST_FUNCTION)
		return (false);

	StringView	name = func_node->function.name;
	Parameter	*params = func_node->function.params;
	size_t		param_count = func_node->function.param_count;
	int			line = func_node->line;
	DataType	return_type = TYPE_INT64;
	bool		is_prototype = func_node->function.is_prototype;

	if (param_count > MAX_PARAMS_PER_FUNCTION)
	{
		error_semantic(errors, filename, line, 0,
				"too many parameters (max %d)", MAX_PARAMS_PER_FUNCTION);
		return (false);
	}

	FunctionInfo *existing = semantic_global_lookup_function(global, name);
	if (existing)
	{
		if (existing->param_count != param_count)
		{
			error_semantic(errors, filename, line, 0,
					"conflicting types for function '%.*s' "
					"(previous declaration at %s:%d had %zu parameters)",
					(int)name.len, name.start, existing->filename,
					existing->line, existing->param_count);
			return (false);
		}

		// Path 1: Existing function is a prototype
		if (existing->is_prototype)
		{
			// If new function is not prototype, update the existing
			// Else, it's a redeclaration
			if (!is_prototype)
			{
				existing->is_prototype = false;
				existing->line = line;
				existing->filename = filename;
				existing->params = params;
				return (true);
			}
			return (true);
		}

		// Path 2: Existing is a definition
		else
		{
			// If new one is also definition, it is an error
			if (!is_prototype)
			{
				error_semantic(errors, filename, line, 0,
						"redefinition of function '%.*s' (previous definition at %s:%d)",
						(int)name.len, name.start, existing->filename, existing->line);
				return (false);
			}
			return (true);
		}
	}

	if (global->function_count >= MAX_FUNCTION_COUNT)
	{
		error_semantic(errors, filename, line, 0,
				"too many functions (max %d)", MAX_FUNCTION_COUNT);
		return (false);
	}

	global->functions[global->function_count] = (FunctionInfo){
		.name = name,
		.return_type = return_type,
		.params = params,
		.param_count = param_count,
		.line = line,
		.filename = filename,
		.is_prototype = is_prototype
	};
	global->function_count++;

	return (true);
}

FunctionInfo *semantic_global_lookup_function(GlobalScope *global, StringView name)
{
	for (size_t i = 0; i < global->function_count; ++i)
	{
		if (sv_eq(global->functions[i].name, name))
			return (&global->functions[i]);
	}
	return (NULL);
}

static bool analyze_node(SemanticAnalyzer *sa, ASTNode *node)
{
	if (node->type != AST_FUNCTION)
		return (false);
	if (node->function.is_prototype)
		return (true);
	sa->current_return_type = TYPE_INT64; // TODO Get from function
	semantic_scope_enter(sa);
	bool params_ok = true;
	for (size_t i = 0; i < node->function.param_count; ++i)
	{
		Parameter *param = &node->function.params[i];
		if (!semantic_scope_declare(sa, param->name, 
					param->type, node->line))
			params_ok = false;
	}

	bool body_ok = true;
	ASTNode *body = node->function.body;
	if (body && body->type == AST_BLOCK)
	{
		for (size_t i = 0; i < body->block.count; ++i)
		{
			if (!analyze_statement(sa, body->block.statements[i]))
				body_ok = false;
		}
	}
	semantic_scope_exit(sa);
	return (params_ok && body_ok);
}

bool semantic_analyze(Arena *a, CompilationUnit *unit, ErrorContext *errors, GlobalScope *global)
{
	SemanticAnalyzer sa = {
		.arena = a,
		.errors = errors,
		.filename = unit->file.name,
		.global = global,
		.current = NULL,
		.current_return_type = TYPE_INT64,
	};

	bool all_ok = true;

	for (size_t i = 0; i < unit->ast->translation_unit.count; ++i)
	{
		ASTNode *node = unit->ast->translation_unit.declarations[i];

		if (node->type == AST_FUNCTION)
		{
			bool already_visible = false;
			for (size_t j = 0; j < sa.visible_count; ++j)
			{
				if (sv_eq(sa.visible_funcs[j], node->function.name))
				{
					already_visible = true;
					break;
				}
			}
			if (!already_visible)
			{
				if (sa.visible_count >= MAX_FUNCTION_COUNT)
				{
					error_semantic(errors, unit->file.name, node->line, 0,
							"too many functions");
					return (false);
				}
				sa.visible_funcs[sa.visible_count++] = node->function.name;
			}
		}
	}

	for (size_t i = 0; i < unit->ast->translation_unit.count; ++i)
	{
		ASTNode *node = unit->ast->translation_unit.declarations[i];
		if (!analyze_node(&sa, node))
			all_ok = false;
	}
	return (all_ok);
}


==================================================
FILE: ./srcs/utils.c
==================================================
#include "utils.h"
#include "layout.h"
#include "file_map.h"
#include <sys/stat.h>
#include <sys/mman.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include "ast.h"

FileMap map_input(int fd)
{
	FileMap res = {0};
	struct stat	stat_buf;
	if (fstat(fd, &stat_buf) == -1)
	{
		close(fd);
		return (res);
	}
	
#ifdef __APPLE__
	int flags = MAP_PRIVATE;
#else
	int flags = MAP_PRIVATE | MAP_POPULATE;
#endif

	char *map = mmap(NULL, stat_buf.st_size,
			PROT_READ,
			flags,
			fd, 0);

	close(fd);
	if (map == MAP_FAILED)
		return (res);

	res.data = map;
	res.length = stat_buf.st_size;
	return (res);
}

void print_ast(ASTNode *node, int indent)
{
	if (!node) return;
	for (int i = 0; i < indent; ++i) printf("  ");

	switch (node->type)
	{
		case AST_FUNCTION:
            printf("Function: %.*s\n", (int)node->function.name.len, node->function.name.start);
            print_ast(node->function.body, indent + 1);
            break;
		case AST_BLOCK:
            printf("Block\n");
            for (size_t i = 0; i < node->block.count; ++i)
                print_ast(node->block.statements[i], indent + 1);
            break;
		case AST_VAR_DECL:
            printf("VarDecl: %.*s\n", (int)node->var_decl.var_name.len, node->var_decl.var_name.start);
            if (node->var_decl.initializer)
                print_ast(node->var_decl.initializer, indent + 2);
            break;
        case AST_ASSIGNMENT:
            printf("Assign: %.*s\n", (int)node->assignment.var_name.len, node->assignment.var_name.start);
            print_ast(node->assignment.value, indent + 1);
            break;
        case AST_RETURN:
            printf("Return\n");
            print_ast(node->return_stmt.expression, indent + 1);
            break;
        case AST_IDENTIFIER:
            printf("ID: %.*s\n", (int)node->identifier.name.len, node->identifier.name.start);
            break;
		case AST_NUMBER:
			printf("Int: %.*s\n", (int)node->number.value.len, node->number.value.start);
			break;
		case AST_ADD:	printf("Op: +\n"); break;
		case AST_SUB:	printf("Op: -\n"); break;
		case AST_MUL:	printf("Op: *\n"); break;
		case AST_DIV:	printf("Op: /\n"); break;
		case AST_CALL:
    		printf("Call: %.*s(", (int)node->call.function_name.len, node->call.function_name.start);
    		for (size_t i = 0; i < node->call.arg_count; i++)
			{
        		if (i > 0) printf(", ");
        		printf("arg%zu", i);
    		}
    		printf(")\n");
    		for (size_t i = 0; i < node->call.arg_count; i++) {
   		    	print_ast(node->call.args[i], indent + 1);
  			}
    		break;
		default:		printf("Unknown node\n"); break;
	}

	if (node->type >= AST_ADD && node->type <= AST_DIV)
	{
		print_ast(node->binary.left, indent + 1);
		print_ast(node->binary.right, indent + 1);
	}
}

void print_header(void)
{
	const char *logo = RESET BOLD GREEN
	BOX_V RESET CYAN "  _   _                                   " RESET BOLD GREEN BOX_V "\n"       
	BOX_V RESET CYAN " | |_(_)_ __  _   _                       " RESET BOLD GREEN BOX_V "\n" 
	BOX_V RESET CYAN " | __| | '_ \\| | | |  " BOLD "tinyCompile v0.1    " RESET BOLD GREEN BOX_V "\n"
	BOX_V RESET CYAN " | |_| | | | | |_| |  " BOLD "Build: release      " RESET BOLD GREEN BOX_V "\n"
	BOX_V RESET CYAN "  \\__|_|_| |_|\\__, |                      " RESET BOLD GREEN BOX_V "\n"
	BOX_V RESET CYAN "              |___/                       " RESET BOLD GREEN BOX_V "\n";
	
	printf(BOLD GREEN BOX_TL);
	for (int i = 0; i < 42; ++i)
		printf(BOX_H);
	printf(BOX_TR "\n");
	printf("%s", logo);
	printf(BOX_BL);
	for (int i = 0; i < 42; ++i)
		printf(BOX_H);
	printf(BOX_BR RESET "\n");
}

void print_phase(int step, const char *name)
{
	const int WIDTH = 42;

	if (step < 0)
		printf("\n" BOLD_RED "[KO] %s" RESET, name);
	else
		printf("\n" BOLD_GREEN "[%02d] %s" RESET, step, name);

	int len = strlen(name) + 4;
	int dots = WIDTH - len;
	if (step < 0)
		printf(DIM RED);
	else
		printf(DIM GREEN);
	for (int i = 0; i < dots; ++i)
		printf(".");
	printf(RESET "\n");
}


==================================================
FILE: ./srcs/validation/validation.c
==================================================
#include "validation.h"
#include "defines.h"
#include "error_handler.h"
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

#define MAX_SOURCE_FILE_SIZE (10 * 1024 * 1024)

bool	validate_source_file(const char *filepath, FileValidation *out, ErrorContext *errors)
{
	memset(out, 0, sizeof(*out));
	bool	valid = true;
	if (!filepath || filepath[0] == '\0')
	{
		error_fatal(errors, NULL, 0, 0, "Empty filepath provided");
		return (false);
	}
	if (strlen(filepath) >= PATH_MAX)
	{
		error_fatal(errors, NULL, 0, 0, "Filepath too long (max %d)", PATH_MAX);
		return (false);
	}
	if (!realpath(filepath, out->canonical_path))
	{
		error_fatal(errors, filepath, 0, 0,
				"Cannot resolve filepath: %s", strerror(errno));
		return (false);
	}
	struct stat st;
	if (stat(out->canonical_path, &st) != 0)
	{
		error_fatal(errors, filepath, 0, 0,
				"Cannot access file: %s", strerror(errno));
		return (false);
	}
	out->exists = true;
	out->size = st.st_size;
	if (!S_ISREG(st.st_mode))
	{
		error_fatal(errors, filepath, 0, 0, "Not a regular file");
		return (false);
	}
	out->is_regular_file = true;
	if (access(out->canonical_path, R_OK) != 0)
	{
		error_fatal(errors, filepath, 0, 0,
				"File not readable: %s", strerror(errno));
		return (false);
	}
	out->readable = true;
	if (!validate_file_size(out->size, MAX_SOURCE_FILE_SIZE, filepath, errors))
		valid = false;
	if (!validate_file_extension(filepath, ".c"))
	{
		error_fatal(errors, filepath, 0, 0, "Expected .c file extension");
		valid = false;
	}
	return (valid);
}

bool	validate_file_extension(const char *filepath, const char *expected_ext)
{
	size_t len = strlen(filepath);
	size_t ext_len = strlen(expected_ext);

	if (len < ext_len)
		return (false);
	return (strcmp(filepath + len - ext_len, expected_ext) == 0);
}

bool	validate_file_size(size_t size, size_t max_size, const char *filepath,
			ErrorContext *errors)
{
	if (size == 0)
	{
		error_add(errors, ERROR_SYSTEM, ERROR_LEVEL_WARNING,
				filepath, 0, 0, "File is empty");
		return (true);
	}
	if (size > max_size)
	{
		error_fatal(errors, filepath, 0, 0,
				"File too large: %zu bytes (max %zu)",
				size, max_size);
		return (false);
	}
	return (true);
}

bool	validate_identifier(const char *name, size_t len, ErrorContext *errors,
			const char *filename, int line)
{
	if (len == 0)
	{
		error_semantic(errors, filename, line, 0, "Empty identifier");
		return (false);
	}
	if (!isalpha(name[0]) && name[0] != '_')
	{
		error_semantic(errors, filename, line, 0,
				"Identifiers must start with letter or underscore");
		return (false);
	}

	for (size_t i = 0; i < len; ++i)
	{
		if (!isalnum(name[i]) && name[i] != '_')
		{
			error_semantic(errors, filename, line, 0,
					"Invalid character '%c' in identifier", name[i]);
			return (false);
		}
	}

	const char *reserved[] = {
		"auto", "break", "case", "char", "const", "continue", "default",
		"do", "double", "else", "enum", "extern", "float", "for", "goto",
		"if", "inline", "int", "long", "register", "restrict", "return",
		"short", "signed", "sizeof", "static", "struct", "switch", "typedef",
		"union", "unsigned", "void", "volatile", "while", "_Bool", "_Complex",
		"_Imaginary"
	};
	for (size_t i = 0; i < sizeof(reserved) / sizeof(reserved[0]); ++i)
	{
		if (strncmp(name, reserved[i], len) == 0 && reserved[i][len] == '\0')
		{
			error_semantic(errors, filename, line, 0,
					"'%.*s' is a reserved keyword", (int)len, name);
			return (false);
		}
	}
	if (len > 255)
	{
		error_semantic(errors, filename, line, 0,
				"Identifier too long (max 255 characters)");
		return (false);
	}
	return (true);
}

bool	validate_integer_literal(const char *text, size_t len, int64_t *out_value, ErrorContext *errors, const char *filename, int line)
{
	if (len == 0)
	{
		error_lexer(errors, filename, line, 0, "Empty number literal");
		return (false);
	}
	if (len > 1 && text[0] == '0' && isdigit(text[1]))
	{
		error_lexer(errors, filename, line, 0,
				"Octal literals not supported (leading zero)");
		return (false);
	}
	errno = 0;
	char		*endptr;
	long long	value = strtoll(text, &endptr, 10);
	if (errno == ERANGE)
	{
		error_lexer(errors, filename, line, 0,
				"Integer literal out of range: %.*s", (int)len, text);
		return (false);
	}
	if (endptr != text + len)
	{
		error_lexer(errors, filename, line, 0,
				"Invalid integer literal: %.*s", (int)len, text);
		return (false);
	}
	*out_value = (int64_t)value;
	return (true);
}


